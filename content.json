{"pages":[],"posts":[{"title":"开源项目被人拿去做课程卖了 1000 多万是什么体验","text":"嗨，大家好，我是小专栏的独立开发者 寂小桦，并不是我的开源项目 被做成网课 售卖了1000 多万，而是小专栏《重学安卓》的作者 KunMinX 为技术专栏做的配套，让读者更好无痛理解 Google 开源的 Jetpack MVVM 中每个架构组件的 存在缘由、职责边界，而 精心设计的一个又一个高频应用场景项目，被某网课拿去做成 对标阿里 P7 课程，售卖了1000多万。 在此呢，为现在良莠不齐的网课 耽误大家学习时间和精力 赚取高额学费 而感到忧心，很多小伙伴因为焦虑 而无脑购买了很多五花八门网课，但是最后都仅限于 在朋友圈转发下 表示自己买了课 而安抚了下自己的焦虑情绪。 其实努力提升自己的确没问题的，在今年这样形式下，更应该是清空自己，努力提升，但是选择课程和专栏一定要慎之又慎，不然到头来钱也花了 时间也浪费了，能力没提升。 好了，今天我文字采访下 KunMinX ，让他说下他为《重学安卓》技术专栏而做的开源项目被卖 1000 多万的体验吧。 小专栏：先给大家作个自我介绍吧KunMinX：很高兴和大家见面！ 我是 专注于 深度思考方法论 和 Jetpack MVVM 的技术博主 KunMinX，目前在小专栏维护有《重学安卓》专栏，相信有不少读者是因为 《Jetpack MVVM 精讲》 这篇文章认识的我。 小专栏：大概介绍一下事情的起因KunMinX：上周四（2020.5.21）被一位网友告知，我开源的《Jetpack MVVM 最佳实践》项目，被 对标阿里 P7 架构师的 价格 6000 多元的某课程，安排了 2 章节 12 课时 拿去给 2300 多名学员讲课。 听到这个消息，我是感到不舒服的。因为这个项目的性质 并非我创作一个 Glide、React 这样的 供生产使用的 原子框架，然后有人去教大家怎么使用， 不是的， 而是，我为了方便开发者们 无痛理解 Google 开源的 Jetpack MVVM 中每个架构组件的 存在缘由、职责边界，而 精心设计的一个又一个高频应用场景，而且项目源码以及《重学安卓》配套文章中 就各种 “为什么” 提供了充分的说明。 （ https://github.com/KunMinX/Jetpack-MVVM-Best-Practice ） 也即，这个项目的核心价值在于 我个人投入了几乎所有空余的精力 独立设计并输出了 关于架构组件的 独家理解。 —— 我的知识产品，在不被打招呼的情况下，就被拿去谋取高额利润 —— 这是我对事情性质的 初步判断，以及导致我 感到被冒犯、不舒服 的原因所在。 小专栏：说说事情的经过KunMinX：于是我第一时间到 桦群主维护的《Android 技术指南读者群》求助，经过热心群友的一番打听后了解到，对方在授课时明确提到了 项目作者和项目地址，但是到此为止，我实际上并不确知，对方是否是照着《重学安卓》配套文章的内容去授课的 —— 这些可都是我无数个日夜付出的心血。 第二天，在群友的介绍下，授课方的 “班主任” 找到我，给我反馈他们 “老板” 给的说法，由于他们所谓的课程内容是保密的，我仍然没有得到确切的消息来界定，课程内容本身是否存在侵权。 与此同时，我在 V2EX 发表的动态 被眼尖的读者发现 并截图贴群里了 （此事发表当天在 V 站共造成了 1W 多次访问 https://www.v2ex.com/t/674335 ） 没想到看到截图，大家马上就认出来，这个课程机构是何方神圣，而且最后有购买过的读者告诉我，“感觉他们讲的 没有你专栏写得好” … 小专栏：事情的后续呢KunMinX：这件事我没有继续追究下去，和授课方 “班主任” 沟通后，我接受了这件事情，从不舒服的状态下走出。 与此同时，有位曾因我分享的深度思考文章而认识我的 来自 V 站的朋友，因在朋友圈看到这件事，而向另一位朋友介绍了我（后者系 Code4App.com 原作者，据该朋友的自我介绍，在2014 年和桦群主一起创业过 … ） 这位朋友和我分享了关于 技术人做知识付费 的一些看法，事实上，正如他所说的，在我开设小专栏、面向公众写作的过去一年里，我几乎是 小专栏、掘金、GitHub、小专栏、掘金、GitHub 三点一线， 我十分感兴趣并且专注于 基于 深度思考方法论 的文章输出，除此之外，作为一名软件开发者，我对市场、营销等领域的认知十分有限，从未到各大公众号宣传过 自己负责的专栏，这也是为什么，一直以来 对待技术文章，我个人都是以 非常较真 的态度来负责 —— 我只知道 并且只剩下口碑了。 —— 有不少读者是通过 好友介绍 加入的《重学安卓》，所以市场上应该还有不少 正需要、但从未听说 过《重学安卓》的读者。而且有的读者跟我说，Android 开发访问官网需要额外支出一笔 “上网费”，他每个月都会通过专栏顶部的 “奖励” 按钮推荐给 1 ~ 2 位朋友，收获的分成 刚好能够补贴当月的 “上网费”。 （每次阶段性更新，我都会在掘金的沸点发布动态，而且看到过几次 读者是借这些动态去推介） https://juejin.im/user/58ab0de9ac502e006975d757/pins 小专栏：为什么坚持深度思考写作KunMinX：就像王垠在微博上的回信中写道：“很多人不是不能知道，而只是不知道”， 也即，很多时候，一些事情并不是你 没有办法知道怎么做，而是你不知道 为什么要做、为什么要这样做 —— 鲜有人 不计成本 地 去提炼这个 “为什么”，然后 再费好几周折 以多数人能听懂的方式 转告给你， 而且我个人始终坚信，每个人都有自驱力，他们缺的就只是 “每当入门一个新的领域时，能有人 事先将这个领域的全貌/状况 给他们做个完整/精确的揭露”， 放到技术上讲，也即 “先把书读薄” —— 任何技术都绝非凭空存在，一项技术的存在，必然是为了 在特定场景下 解决特定问题 —— 务必先交代 背景状况、存在缘由、职责边界，让读者 对这个技术的存在 先有个感性认识，然后这时候 读者基本就能顺着文章提供的切入点，做到快速上手。 这也是 深度思考写作 的意义之所在。 那些 东拼西凑、人云亦云、通篇贴代码 的网文 让我感到不舒服，因为不仅没能为 包括我在内的读者们 解决疑惑，反倒徒添困扰 —— 这是 身为写作者的我 最不能容忍的 —— 传道和解惑 本该是每个写作者 最初 &amp; 最后的底线，而我也只不过是做了一件写作者该做的事，没想到却成了《重学安卓》专栏的特质所在。 小专栏：专栏更新的频率是怎样的KunMinX：事实上，《重学安卓》专栏每天都有新的读者加入，为了方便新读者能够 安心地把文章看完，专栏采取 宁缺毋滥 且体系化、精进化 的模式经营 —— 从不疯狂扩充文章，反而小心翼翼地控制数量、不断打磨、翻新 甚至 增量更新旧文章。 每当听到有读者向我分享 他们阅读完的感受 —— “醍醐灌顶、豁然开朗” —— 我都会感到很开心。 是的，从始至终，《重学安卓》专栏只做这么一件事 —— 专注于深度思考写作输出，以及 不定期地 对前沿热门的 Jetpack MVVM 架构组件 等知识进行 增量更新 —— 就只深耕这一件事。 小专栏：《重学安卓》的氛围怎么样KunMinX：事实上，专栏读者高手如云： HenCoder kotlin 专家 高杰老师 以及从《Android 技术指南读者群》过来的多位大佬 订阅支持了《重学安卓》专栏。 数十位来自 百度、阿里、腾讯、字节跳动、华为、OPPO 等知名公司的小伙伴，群里不定期会有小伙伴提供内推机会。 而且小伙伴们有各自专注的领域，有的小伙伴专注 ROM 底层研究，有的专注于自定义 View 而且还热心地帮助过其他小伙伴解决这方面的问题，还有不少小伙伴是从 Web 前端、后端、iOS 或者 嵌入式转过来的，群里经常会讨论一些实际工作中遇到的适配等问题。 可以给大家展示一下专栏文章的评论区： 《重学安卓》专栏 不仅仅是我一个人的创作，也是集许许多多优秀读者 参与互动的演化的结果。 有些热心读者 指出某些段落存在的逻辑矛盾，让我感觉到 文章有被认真阅读， 有些读者在反复阅读后，就细节上的困惑 实事求是地讨论，并且方便了后来的读者，这也是我十分乐意看到的， 有的小伙伴不光阅读了，还超出了我的期望 —— 没有满足于文末给的结论，而是踏踏实实地 对配套项目进行测试和记录一番，并最终指出了一处小纰漏。 当然也有小伙伴在多个月后 温故而知新，分享新的感悟。 以及读者群小伙伴分享的感受： 而且很高兴有读者告诉我，受《重学安卓》专栏 “深度思考” 的启发，他们也开始了写作之路。其中一位还在鸿洋老师的《崛起》篇中被推介。 做个收尾这一期的访谈，作者 KunMinX 为我们带来了《重学安卓》专栏和它的故事。 我作为小专栏平台的开发者兼管理员，在过去一年里一路见证了《重学安卓》以及其他优秀专栏的成长，借此机会向各位在 各自领域的专注和输出 致敬。 小专栏始终 尊重和维护创作者 享有完整的著作权，坚持向读者推荐优质的、深度写作的文章内容。 本期介绍的《重学安卓》专栏可点击此链接前往：https://xiaozhuanlan.com/kunminx 有兴趣的朋友订阅后 可以进入作者的读者群，详细交流。 本文以 CC 署名-非商业性使用-禁止演绎 4.0 国际协议 发行。 Copyright © 2020 寂小桦 &amp; KunMinX","link":"/2020/05/25/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A2%AB%E4%BA%BA%E6%8B%BF%E5%8E%BB%E5%81%9A%E8%AF%BE%E7%A8%8B%E5%8D%96%E4%BA%86%201000%20%E5%A4%9A%E4%B8%87%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%93%E9%AA%8C/"},{"title":"是让人耳目一新的 Jetpack MVVM 精讲啊！","text":"前言很高兴见到你！ 最近在后台 时有收到 读者的留言，说能不能出一期 Jetpack MVVM 精讲，以及配套一份简练的案例，好 把玩把玩、感受感受、加深对 MVVM 的印象。 答案当然是肯定的。😉 面向标准化开发已成现实金九银十，相信有不少读者在抓紧机会面试。 Android 市场已今非昔比。在过去，迫于招人的压力，应试者只需了解四大组件、视图、网络请求，即可谋得一份满意的工作。 现如今，Jetpack 架构组件 及 标准化开发模式 的确立，意味着 Android 开发已步入成熟阶段： 许多 样板代码 不再需要开发者手写，而是可以通过模版工具 自动生成，在取缔繁杂耗时的重复工作的同时，避免因人工操作的疏忽，而造成难以排查、不可预期的错误。 这十分符合企业的利益，因而面试官在招人的时候，也更加看重应试者对 架构组件 —— 至少是 MVVM 的理解程度。🧐 像“解耦”等 含糊其辞的说法，已经不能够被面试官所认可，稍微对 MVVM 有一点经验的面试官都会请你举例说明，好证明你确实对 MVVM 有着正确、深入的理解，能够自然而然地写出标准化、规范化的代码，能够迅速适应 各家公司自制的 自动化模版工具。 本文的目标本人拥有 3 年的 移动端架构 践行和设计经验，领导团队重构的中大型项目多达十数个，对 Jetpack MVVM 架构在确立规范化、标准化 开发模式 以减少不可预期的错误 所作的努力，有着深入的理解。 因而本文的目标，就是结合前几期我们分别 深入浅出 介绍过的 Lifecycle、LiveData、ViewModel、DataBinding，来融汇贯通地演绎一下： 作为 应用开发骨架 的 标准化状态管理框架，究竟为 快速开发过程中 减少不可预期的错误 做了哪些努力。 不同于 东拼西凑、人云亦云、徒添困扰 的网文，愿意将 标准化开发模式的 深度思考知识 和 实战反思经验 无保留地分享，全网仅此一家。这样的文章可以说是 看一篇、少一篇，因此，就算不去 hold 住面试官，也请务必跟随本文的脚步，无障碍地将 Jetpack MVVM 过一遍！😉 文章目录一览 前言 面向标准化开发已成现实 本文的目标 Jetpack Lifecycle Lifecycle 存在前的混沌世界 Lifecycle 为什么能解决上述这些问题？ Jetpack LiveData LiveData 存在前的混沌世界 LiveData 为什么能解决上述这些问题？ LiveData 有个坑需要注意 Jetpack ViewModel ViewModel 存在前的混沌世界 ViewModel 为什么能做到这几点？ Jetpack DataBinding DataBinding 存在前的混沌世界 DataBinding 就是来解决这些问题 综上 Jetpack Lifecycle Lifecycle 的存在，主要是为了解决 生命周期管理 的一致性问题 Lifecycle 存在前的混沌世界在 Lifecycle 面市前，生命周期管理 纯靠手工维持，这样就容易滋生大量的一致性问题。 例如跨页面共享的 GpsManager 组件，在每个依赖它的 Activity 的 onResume 和 onPause 中都需要 手工 激活、解绑 和 叫停。 那么 随着 Activity 的增多，这种手工操作 埋下的一致性隐患 就会指数级增长： 一方面，凡是手工维持的，开发者容易疏忽，特别是工作交接给其他同事时，同事并不能及时注意到这些细节。 另一方面，分散的代码不利于修改，日后除了激活、叫停，若有其他操作需要补充（例如状态监听），那么每个 Activity 都需要额外书写一遍。 Lifecycle 为什么能解决上述这些问题？Lifecycle 通过 模板方法模式 和 观察者模式，将生命周期管理的复杂操作，全部在作为 LifecycleOwner 的基类中（例如视图控制器的基类）封装好，默默地在背后为开发者运筹帷幄， 开发者因而得以在视图控制器（子类）中只需一句 getLifecycle().addObserver(GpsManager.getInstance) ，优雅地完成 第三方组件在自己内部 对 LifecycleOwner 生命周期的感知。 除了解决一致性问题，这样做还 顺带地提供了其他 2 个好处： 1.规避 为监听状态 而 注入视图控制器 的做法 当需要监听状态时，以往我们的做法是 通过方法手工注入 Activity 等参数，这埋下了内存泄漏的隐患 —— 因为团队中的新手容易因这是个 Activity，而在日后误将其依赖给组件中的其他成员。 现如今，我们可以直接在组件内部 点到为止 地监听 LifecycleOwner 的状态，从而规避这种不恰当的使用。 2.规避 为追溯事故来源 而 注入视图控制器 的做法 当发生事故时，以往我们若想在组件中 追溯事故来源，同样不得不从方法中直接注入 Activity 等，这同样埋下了内存泄漏的隐患。现如今组件因实现了 DefaultLifecycleObserver，而得以通过生命周期回调方法中的 LifecycleOwner 参数，在方法作用域中 即可得知事故来源，无需更多带有隐患的操作。 如果这么说还不理解的话，可具体参考我在 《为你还原一个真实的 Jetpack Lifecycle》 中提供的 GpsManager 案例，本文不再累述。 Jetpack LiveData LiveData 的存在，主要是为了帮助 新手老手 都能不假思索地遵循 通过唯一可信源分发状态 的标准化开发理念，从而使在快速开发过程中 难以追溯、难以排查、不可预期 的问题所发生的概率降低到最小。 LiveData 存在前的混沌世界在 LiveData 面市前，我们分发状态，多是通过 EventBus 或 Java Interface 来完成的。不管你是用于网络请求回调的情况，还是跨页面通信的情况。 那这造成了什么问题呢？首先，EventBus 只是纯粹的 Bus，它 缺乏上述提到的 标准化开发理念 的约束，那么人们在使用这个框架时，容易因 去中心化 地滥用，而造成 诸如 毫无防备地收到 预期外的 不明来源的推送、拿到过时的数据 及 事件源追溯复杂度 为 n² 的局面。 并且，EventBus 本身缺乏 Lifecycle 的加持，存在生命周期管理的一致性问题。这是 EventBus 的硬伤，也是我拒绝使用 EventBus 的最主要因素。 对上述状况不理解的，可具体参考我在 《LiveData 鲜为人知的 身世背景 和 独特使命》 中提供的 播放器状态全局通知 的案例 LiveData 为什么能解决上述这些问题？首先，LiveData 是在 Google 希望确立 标准化、规范化 的开发模式 —— 这样一种背景下诞生的，因而为了达成这个艰巨的 使命，Google 十分克制地将其设计为，仅支持状态的输入和监听，从而，它不得不 在单例的配合下，承上启下地完成 状态 从 唯一可信源 到 视图控制器 的输送。 （ViewModel 姑且也算是一种单例，一种工厂模式实现的伪单例。唯一可信源是指 生命周期独立于 视图控制器的 数据组件，通常是 单例 或共享 ViewModel） 这使得任何一次状态推送，都可预期、都能方便地追溯来源，而不至于在 事件追溯复杂度为 n² 的迷宫中白费时间。（即，无论是从哪个视图控制器发起的 对某个共享状态改变的请求，状态最终的改变 都由 作为唯一可信源的 单例或 SharedViewModel 来一对多地通知改变） 并且，这种承上启下的方式，使得单向依赖成为可能：单例无需通过 Java Interface 回调通知视图控制器，从而规避了视图控制器 被生命周期更长的单例 依赖 所埋下的内存泄漏的隐患。 LiveData 有个坑需要注意不过，LiveData 的设计有个坑，这里我顺带提一下。 为了在视图控制器发生重建后，能够 自动倒灌 所观察的 LiveData 的最后一次数据，LiveData 被设计为粘性的事件。 —— 我姑且认为这是个拓展性不佳的设计，甚至可以说是一个 bug， 因为 Jetpack MVVM 是一个整体，既然 ViewModel 支持共享作用域，并且官方文档都承认了通过 共享 ViewModel 来实现跨页面通信的需求， 那么基于 “开闭原则”，LiveData 理应提供一个与 MutableLiveData 平级的底层支持，专门用于非粘性的事件通信的情况，否则直接在跨页面通信中使用 MutableLiveData 必造成 事件回调的一致性问题 及 难以预期的错误。 关于非粘性 LiveData 的实现，网上存在通过 “事件包装类”（只适合 kotlin 的情况） 和 “反射干预 LastVersion” （适用于 Java 的情况）两种方式来解决： https://juejin.im/post/5b2b1b2cf265da5952314b63 https://blog.csdn.net/geyuecang/article/details/89028283 无论是使用哪一种实现，我都建议 遵循传统 LiveData 所遵循的开发理念，通过唯一可信源分发状态，来方便事件源头的追溯。对于 “去中心化” 的 Bus 方式，我拒绝在项目中这样使用。 Note 2020.5.31： Event 包装器 重写底层 EventLiveData 手写 Event 事件包装器，在 Java 中存在 null 安全的一致性问题；而反射干预 Version 的方式又存在延迟（无法用于对实时性有要求的场景）、并且数据会随着 SharedViewModel 长久滞留在内存中得不到释放。 于是我重写并封装了专用于 “一次性的事件” 场景需求的 EventLiveData。具体可参考 《最佳实践》 项目最新源码。 Jetpack ViewModel ViewModel 的存在，主要是为了解决 状态管理 和 页面通信 的问题。 ViewModel 存在前的混沌世界ViewModel 的本职工作是 状态托管 和 状态管理的分治，也即当视图控制器重建时， 对于轻量的状态，可以通过视图控制器基类的 saveInstanceState 机制，以序列化的方式完成存储和恢复。 对于重量级的状态，例如通过网络请求得到的 List，可以通过生命周期长于视图控制器的 ViewModel 持有，从而得以直接从 ViewModel 恢复，而不是以效率较低的序列化方式。 在 Jetpack ViewModel 面市之前，MVP 的 Presenter 和 MVVM - Clean 的 ViewModel 都不具备状态管理分治的能力。 Presenter 和 Clean ViewModel 的生命周期都与视图控制器同生共死，因而它们顶多是为 DataBinding 提供状态的托管，而无法实现状态的分治。 到了 Jetpack 这一版，ViewModel 以精妙的设计，达成了状态管理，以及可共享的作用域。 ViewModel 为什么能做到这几点？其实这版主要是基于 工厂模式，使得 ViewModel 被 LifecycleOwner 所持有、通过 ViewModelProvider 来引用， 所以 它既类似于单例：—— 当被作为 LifecycleOwner 的 Activity 持有时，能够脱离 Activity 旗下 Fragment 的生命周期，从而实现作用域共享， 实际上又不是单例：—— 生命周期跟随 作为 LifecycleOwner 的视图控制器，当 Owner（Activity 或 Fragment）被销毁时，它也被 clear。 此外，出于对视图控制器重建的考虑，Google 在视图控制器基类中通过 retain 机制对 ViewModel 进行了保留。 因此，对于 作用域共享 和 视图重建 的情况，状态因完好地被保留，而得以被视图控制器在恢复时直接使用。 再者，由于存在 共享作用域的考虑，所以 ViewModel 本身也承担了跨页面通信（例如事件回调）的职责。前面在介绍 LiveData 时，对于 LiveData 在事件通信时粘性设计的问题已经介绍过了，这里不再累述。 截至 2020.2.1，ViewModel 在 Fragment 中的 retain 设计已发生剧变，具体缘由可参考我在 《有了 Jetpack ViewModel . . . 真的可以为所欲为！》 文末及评论区的最新补充。 Jetpack DataBinding DataBinding 的存在，主要是为了解决 视图调用 的一致性问题。 DataBinding 存在前的混沌世界在 DataBinding 面市前，我们若要改变视图的状态，首先就要引用该视图，例如 textView.setText()， 这造成什么问题呢？ 当页面存在横、竖布局，且两种布局的控件存在差异，例如横屏存在 textView 控件，而竖屏没有，那么我们就不得不在视图控制器中为 textView 做判空处理，这就造成了一致性问题 —— 容易疏忽而忘记判空，毕竟页面多达数十个、每个页面的控件也无数。 那怎么办呢？ DataBinding 就是来解决这些问题通过在布局中与可观察的数据发生绑定，那么当该数据被 set 新的内容时，控件也将得到通知和刷新。 换言之，在使用 DataBinding 后，唯一的改变是，你无需手工调用视图来 set 新状态，你只需 set 数据本身。 因而，DataBinding 并非许多人不假思索认为的，将 UI 逻辑搬到 XML 中写 从而难以调试 —— 事实根本不是这样的： DataBinding 只负责绑定数据、负责作为 UI 逻辑末端的状态的改变（也即它是一个不可再分的原子操作，本来就不需要调试），原本在视图控制器中 UI 逻辑怎么写，现在还是怎么写，只不过不再需要 textView.setText(xxx)，而是直接 xxx.set()。 所以在 DataBinding 的帮助下，好处总共有多少个呢？ 1.规避了视图状态的 一致性问题 —— 无需手工判空。 2.规避了视图状态的 一致性问题，乃至无需视图调用，从而完全不用编写 findViewById。 3.就算要调用视图，也不用 findViewById，而是直接通过 binding 来引用。 4.先前的 UI 逻辑基本不用改动，改的只是作为末端的状态改变的方式。 …… 此外，DataBinding 有个大杀器就是，能为控件提供自定义属性的 BindingAdapter，它不仅可以解决 圆角 Drawable 复用的问题（你懂得），还可以实现 imageView 直接绑定 url 等需求，总之，没有它办不到的，只有你想不到的，DataBinding 的好处等着你挖掘。😉 关于 DataBinding 的注意事项，以及屡试不爽的排坑技巧，可具体参考 《从 被误解 到 真香 的 Jetpack DataBinding！》，这里不做累述。 综上Lifecycle 的存在，主要是为了解决 生命周期管理 的一致性问题。 LiveData 的存在，主要是为了帮助 新手老手 都能不假思索地 遵循 通过唯一可信源分发状态 的标准化开发理念，从而在快速开发过程中 规避一系列 难以追溯、难以排查、不可预期 的问题。 ViewModel 的存在，主要是为了解决 状态管理 和 页面通信 的问题。 DataBinding 的存在，主要是为了解决 视图调用 的一致性问题。 它们的存在 大都是为了 在软件工程的背景下 解决一致性的问题、将容易出错的操作在后台封装好，方便使用者快速、稳定、不产生预期外错误地编码。 这样说，你理解了吗？😉 GitHub : Jetpack-MVVM-Best-Practice 版权声明本文以 CC 署名-非商业性使用-禁止演绎 4.0 国际协议 发行。 Copyright © 2019-present KunMinX 文中提到的 “Jetpack MVVM 架构组件的存在，是为了在多人协作的软件工程的背景下，解决各种一致性的问题”，以及 “LiveData 在页面通信、事件回调的场景下发生 数据倒灌” 等多处 对特定现象及其本质的概括，均属于本人独立原创的成果，本人对此享有最终解释权。 任何个人或组织在引用 “xxx 架构组件的存在，主要是为了解决 xxx 的一致性问题”、“数据倒灌” 这些概括性描述时，须注明原作者和出处。未经授权不得用于洗稿、广告包装等商业用途。","link":"/2019/10/23/%E6%98%AF%E8%AE%A9%E4%BA%BA%E8%80%B3%E7%9B%AE%E4%B8%80%E6%96%B0%E7%9A%84%20Jetpack%20MVVM%20%E7%B2%BE%E8%AE%B2%E5%95%8A%EF%BC%81/"},{"title":"免疫网络暴力和打压的终极认知补丁","text":"前言很高兴见到你！ 看到上周我在 掘金沸点 发布的动态，有不少小伙伴都表示关心，这篇文章大体会介绍些什么、能不能解决他们 在人际关系中 频频遇到的困扰。 答案当然是肯定的~ 😉 身陷烦恼时，从未有人给过你专业的聆听 相信有不少读者遭遇过以下情形： 在网上被网友 阴阳怪气地评论，不知道为什么，但就是觉得不对劲、不舒服， 在职场被上司 布置 2~3 个人分量的任务，完不成自己看着办，就好像完不成不是管理不当，是你不行。 生活中常常被否定，鼓起勇气发表精心打磨的作品，却被喷得一无是处 …… 每当这个时候，你想要找人诉说时，却发现无人可以诉说， 朋友可能会告诉你，“这有什么，多大的事啊，不要在意别人的看法，看开点”， 网友可能会告诉你，“是你太玻璃心了；你心理素质也太差了；我觉得是你有问题”， 教科书可能会告诉你，“多喝热水，多运动运动，培养兴趣，转移注意力就好了”， 自媒体可能会告诉你，“这边又有个公众人物说些大跌眼镜的话啦，想解气吗？快来骂他”， 心理学畅销书可能会告诉你，“爱，可以疗愈一切伤害” …… 对此你可能早有体会 —— 每当你正处于困扰漩涡的中心，需要有人提供体贴的理解或专业的聆听、带你从困扰中走出来时，实际你所能接触到的、或是主动找上门来的，多是些 不着调的 “猪头”，不仅不能解决问题，反倒 … 嗯。 有的人，因为一再的困扰而患上抑郁，更有人因无法承受 挥之不去的精神痛苦 而选择自尽。 本文的目标我相信多数读者都是因为 《 Jetpack MVVM 精讲》 这篇文章 认识的我，事实上，除了 “技术博主” 这个身份，我还有个隐秘的身份 —— 在 自我认知、心理学领域 专注耕耘了 13 年，对网络暴力和 PUA 背后所映射的 一整套完整的结构和机制 有深入的理解，能够提供区别于 普通大众读物 的 专业背景认知 和 行之有效的免疫方案。 换言之，本文的目标绝不是追责 —— 我无意像某些自媒体，轻车熟路地给公共事件中的人物贴标签、制造对立，然后煽动读者情绪、从道德层面予以谴责和攻击。 恰恰相反，我要看到那些 有意自我成长 的读者 被及时打上 必要且终极的认知补丁，有了这些补丁，以后无论再遇到多少这样的事件，都能保持无惑和淡定、从根本上杜绝 因挥之不去的困扰 而造成心理上的不适 和精神上的痛苦。 考虑到 愿意且能够跨界 将体系化的结构和逻辑 整合并分享 的，全网仅此一家，并且本文分享的认知，放在 5000 年前或是 5000 年后仍然适用 —— 是贯穿一生的适用、会了就是会了，而且这样的文章 从前乃至往后 就只分享这么一篇 —— 因此 就算当下读完一遍感觉理解了，也请务必收藏好、放在最重要的地方，以时时提醒更好地生活。 文章目录一览 前言 身陷烦恼时，从未有人给过你专业的聆听 本文的目标 免疫补丁问世前的混沌世界 为什么免疫补丁能踩到点上 认知一：人是基于认知来行动的生物 认知二：没有过去和未来，只有当下 认知三：最高频的现象是自利 所以网络暴力和 PUA 究竟做了什么? 所以该如何有效应对 网络暴力和 PUA 呢？ 综上 免疫补丁问世前的混沌世界以自己的经历来举例好了。 1 年前，出于 对独立原创作品的付出 有被人尊重的需要，我在小专栏平台开设了 专注于 深度思考方法论 和 Jetpack MVVM 的 《重学安卓》付费专栏。 这是我发挥才干的地方，我就像对待自己的孩子一样，用心对待自己发表的每一篇文章。负责任地说，为了 让读者们能够无痛地理解状况，每篇文章在发表前，都经历了不少于 2 周时间的酝酿；在发表后的 2 天里，更是不间断地反复全文通读、修改纰漏，确保每个细节阅读起来都能十分流畅。 此外，《重学安卓》专栏 不仅仅是我一个人的创作，也是集许许多多优秀读者参与互动的演化的结果。 有些热心读者 指出某些段落存在的逻辑矛盾，让我感觉到 文章有被认真阅读， 有些读者在反复阅读后，就细节上的困惑 实事求是地讨论，并且方便了后来的读者，这也是我十分乐意看到的， 有的小伙伴不光阅读了，还超出了我的期望 —— 没有满足于文末给的结论，而是踏踏实实地 对配套项目进行测试和记录一番，并最终指出了一处小纰漏。 当然也有小伙伴在多个月后 温故而知新，分享新的感悟。 总之看到这些消息，我都会很开心。 直到 评论区冷不丁地出现了这样的评论： 朋友们，看到这样的评论，你的第一反应是啥？ 如果你 一眼就认清了事情的性质，而无视对方具体说了什么，那么大概率你已心智成熟，这样的事就算发生在自己身上，你也能淡然处之。 反之，如果看到这样的评论，身为局外人的你 脑袋一片空白，还需要想一下、然后找个合理的解释 —— “这没什么，这有什么，这很正常”，那么在往后亲历这样的事件时，你或许会 毫无招架之力，因为目前为止 都还未确立有认知 来帮助你确知 事情的性质 和有效作出应对。 身为当事人的我，那个 完全站在读者的角度写作、对文章内容极端负责 的我，在尚未持有认知补丁的情况下，遇到这条评论，我是什么反应呢？ 直觉上知道，这条评论 不对劲、让我感到 不舒服，但我那时并不确知为什么。 出于对目标读者负责的考虑，我想删评论，但没有看到删除按钮， 我随即发表了声明： 没想到这个人接下来的评论 让彼时的我 直接原地爆炸： 到了这里，我真的是气坏了，深深感觉到被侮辱， 于是破了规则，去烦着管理员退订此人，并且以牙还牙回怼，搬出只有极端情况下才会使用的道德武器 不留余地地对这个 挑衅规则、推卸责任 的行为进行谴责和围剿， 这么做有没有解决问题呢？ 有，但是代价太大了，或者用我现在的话来说就是，没踩到点上，通过 杀鸡用牛刀的方式 来解决问题。 整件事前前后后损耗了我一周的注意力，包括写作在内的 所有需要高度集中注意力的活动 全部被迫中断，对方的行为 在精神上给我造成的损失 绝不少于彼时订阅价格的 100 倍。 那读者们可能会问了，遇到此类事情，怎样才能踩到点上、被踩到的点又是什么呢？ OK，接下来就循序渐进地介绍 3 个从未有人给你开源过的必要认知。 为什么免疫补丁能踩到点上认知一：人是基于认知来行动的生物这个世界并不像你们想象的那么美好，多数人从小被灌输和洗脑，不假思索地接受某些刻意编造的谎言，然后自欺欺人、心安理得地 随波逐流、自暴自弃。 例如 “性格” 这个词，其背后的隐含的暗示是，“人是没有改变的可能的，生下来是什么样的，就是什么样的，人是电路板焊死的计算器，而不是冯诺依曼 可编程计算机”， 一切的改变，都是从明确地意识到，“人是 基于 ‘认知’ 来行动 的生物”，开始的 —— 当你 确知一件事情的意义，确知做了它就能给别人带来什么好的结果，你就会去做这么件事情，因为既然你有能力向别人输出价值，你就有机会基于 “价值交换” 这一最基本的社会规则，通过付出来换取 物质、心理 或 精神上的回报 —— 这就是你之所以 做或不做、持续做或从不做某事的原因 —— 你确知事情的意义，所以才会去做，你不确知，你就空空手站在那里、觉得尴尬，不知道自己能做些什么。 （所以自那以后，我主动拒绝了 95% 的不必要的社交活动，因为我确知 如果我不懂在场是为了什么、能为别人解决什么问题，去就是浪费时间、白尴尬。与此同时，“性格内向” 的我 也曾 因确知歌舞能在年会上 向观众传递热情，而破天荒地登台领舞并演唱 G-Dragon 的《Crooked》，而且没想到的是，最后我们团队因该节目获得 84 枚投票而占据节目榜单第 2 名） 认知二：没有过去和未来，只有当下可能听说 “活在当下” 这个词的人不在少数，但有多少人 正确理解了这个词的含义呢？ 最早我是在 2011 年接触了 “当下” 这个词，但确知其正确含义，是在 2017 年底，在技术经理的推介下，玩 QQ飞车手游 领悟的。 QQ 飞车是一款竞速游戏，竞速游戏的目标是什么？—— 用更少的时间到达终点。 那么达成这一目标的办法是什么？ 好多 ‘青铜’ 在玩游戏时，全靠使蛮劲、凭感觉，结果事倍功半，自己把自己劝退， 按鸡汤文的逻辑，‘强者’ 一定是比 ‘弱者’ 更努力，那么排位 TOP 的 ‘王者’，难道是能把屏幕捏穿 所以才一路晋升到最强车神么？ 绝不是的 虽说 抽象/普遍/宏观 意义上讲，最终的目的是 用更少的时间到达终点，然而事实上，只要你开局了，当下你就已经处于跑道中，而且无论你是处于哪个跑道，它们都是由多个普适且不可再分的 ‘原子路段’ 组成的 —— 例如它们都包含多个直道或弯道，而你只要这一当下掌握了 能快速通过直道 或快速过弯 的认知和技能（比如 “CWW” 或 “进阶氮气出弯”），那下一个当下遇到类似的状况，你同样能游刃有余地解决， 这，就是 ‘活在当下’ 的正确含义！ 许多人在广告和媒体的洗脑下，总是漫无目的地焦虑未来、然后不断地碌碌无为和拖延时间。事实上，根本不存在未来，只要你着眼于当下，去把 每个当下都绕不开的基本功 给打扎实，你这个当下能胜任，你下个当下也就同样能胜任，这就是活在当下，也只有活在当下！ 生活不像 QQ飞车这么友好，会主动公开地将 CWW、进阶氮气过弯 这样的 高频概念 送到你嘴边， 因而这里 需要再次确知的是，你需要不断 追忆、观察并提炼出 生活中的高频状况（好比直道或弯道），然后你还要负责去学习和掌握 应对这些高频状况的 具体认知和技能，如此你才有机会 hold 住，才有机会一路晋升成为王者。 👆👆👆 划重点 认知三：最高频的现象是自利那么这里我最后分享一条 可遇不可求 的认知，这条认知是所有 ‘具体认知’ 里面，最最高频的认知，有不少人就是因为这条认知的缺乏，在重重困扰下患上抑郁，甚至付出了生命。而确知了这条认知，许多困扰却都能迎刃而解、烟消云散。因而 即使忘了其他认知，也务必消化 并终其一生地牢记 这条认知。 对于这条认知的推导过程，我不想多作解释，直接说结论： 人的一切行为都是自利的 这是人的一生当中，不离身的 最最高频的 真相。 试着追忆和观察一下便知，当下你发起的每一个行动，都是出于自利，无论是 物质、心理 还是精神上的自利， 从所谓低级的欲望： 想吃美食，想见好看的人儿，想晒旅游的照片， 为了满足安全感 而被迫做些利他的事情， 为了低成本地满足存在感，而在他人作品的评论区下 居高临下地 比较、歪曲 或 攻击，等等； 到所谓高级的欲望： 想掌握一条认知和技能，并创作和分享给更多人。 事实上，欲望之间其实并没有所谓 “高低级” 之分，真正存在区别的，是在满足欲望的同时，是否损害了他人的正当权益，也即只有 利人利己 和 损人利己 之分。 好，那么至此，我们确知了，人的一切行为都是自利的 —— 来了，就是来利己的，来了还损人的，就是损人利己的。 所以网络暴力和 PUA 究竟做了什么所以套用第三条认知，你再回过头来看看 开头我们提到的这个人的评论， 现在你确知了事情的性质了吗？ 这个人在做什么？—— 不管做什么，来了，就是来干嘛？来利己的， 来了他还做了什么？当事人是不是因为他的言论 而感到不对劲、不舒服？是，那么来了就是来损人的，事情的性质就是 —— 是他在损人利己。就这么简单。 于是无论他具体说了些什么，都不重要了，已经确知了，这个人就是来损人利己的。 明白这里面的区别吗？ 需要我再展开讲解一下吗？ 要？ 不要？ 要？ 不要？ 好嘛，那就再精要地剖析一下 这其中到底发生了怎样的剧变。 在确立了第三条认知之前，当事人是什么情况呢？ 被人阴阳怪气地说了一些话，当事人觉得不对劲、不舒服，但不知道为什么，并且 非常困扰、陷入其中， 为什么会陷入其中？ 这里面还有个很关键的 被人忽视的细节 —— 会陷入其中，是因为，人类 对确定感的需要，决定了在事发时，人们需要找到一个合理的解释，来接受事情的发生， 反复强调三遍： 是人类对 确定感 的需要， 是人类对 确定感 的需要， 是人类对 确定感 的需要， —— 既然对方 无中生有 地说了一些话，那么如果不是 有 对事情性质的确知 在先、予以 条件反射级的揭露 和盖棺定论，就会无意识地、不受控制地 被触发 “合理化思维” —— 合理化他对你的贬低， 他说你的作品毫无营养，他本质上是在通过你的 ”合理化思维“ 来 暗示你在地位上的低人一等 —— 你不好、你不行、你不配 —— 本质上就是制造了关系的不平等、你被当成了低人一等的奴隶， 而你在潜意识里 基于合理化思维 制造的 被扭曲的自我认知，与意识里努力塑造和维持的自我认知 发生了冲突，这就是你感到 “不舒服” 的最根本原因。 并且当你在意识上确知 事实根本不是他讲的那样，就会直接让你原地爆炸 —— 别人恣意妄为地挖坑 以此为筹码 来试图控制和奴役你，而你却无意识地 拼命往坑里跳 去证明自己 ……（对方可能心里还在纳闷，咦，怎么回事，事情的走向不太对啊，我就是想找个理由做点越界的事而已，怎么没有乖乖听话就范呀？） 那既然危害如此巨大，为什么对方还要损人利己呢？ 利人利己的事，通常发生在我们具备特定的专业能力，而主动去做， 损人利己，主要是在 认知不足、看不到别的出路、又十分想要做一些规则不允许的事情 时发生， 损人者在潜意识里自知这是做亏心事，因而通过贬损他人来合理化自己的行为 —— 向潜意识暗示自己行为的合理性，避免良心感到不安 —— 于是就有了 采取掩耳盗铃的方式，试图瞒天过海地 越界侵犯。 但这件事坏就坏在，不仅暗示了他的潜意识，还暗示了当事人的潜意识。 —— 多数人在权益被侵犯时，往往不具备相应的认知 来条件反射级拦截， 他们的头脑里 根本没有预装过并确知 “自利”、“损人利己” 这些概念，乃至遇事时，他们根本想不到 “居然还有这样” —— 用这个来解释事发的合理性（没有这个脑回路），于是在不受控制的合理化思维下，转而攻击自己，认为是自己不好、自己不行、自己不配，于是想要做些什么 来完成自我救赎（而事实上，陷在里面的人，无论做什么、怎么做，都无法摆脱这种困扰和精神痛苦，于是也就有了 “认知三” 一节提到的 选择自尽的那位员工的遭遇）。 —— 这也是为什么 损人者会屡试不爽，他知道只要贬损你，你就会招架不住，并且唯命是从、任人摆布。 而他如果知道，为了自己小小的利益，竟给当事人造成 10倍、100倍的损害 甚至付出生命，那他还会不会这样做呢？ 所以该如何有效应对 网络暴力和 PUA 呢？通过上述分析，我们已确知了，整个逻辑是： 在网络暴力和 PUA 发生时，本质上是 人与人的关系被扭曲为不平等、当事人在关系中的地位 被不受控制地暗示为低人一等、当事人的自我认知遭到严重扭曲 而发生心理或精神上的紊乱。 因而免疫和跳出的方式就是，通过暗示的手法来揭露对方的侵权 —— 从而暗示了自身权益的存在，而自身权益的存在，再次间接暗示了自己与对方在关系中、在地位上的平等 —— 瞬间恢复平等 —— 潜意识是不受控制的，这一切都务必通过暗示，用暗示的手法 来覆盖来自对方的暗示。 如此，我方将从被动化为主动，情况就进一步被推进成 对方要么进，要么退 —— 既然他只知损人而无力输出价值、满足要求，他就只能接受现实 灰溜溜地（或骂骂咧咧地）离开。 那怎么暗示对方在侵权呢？ 这个我们可以结合具体情况 来选择合适的应对方式。 —— 在 属于自己负责的领地，和 不属于自己负责的领地，分别采取不同的方式来应对。 但 最终的最终，都是在不越界侵犯的前提下，合理维持 关系中地位的 动态平衡。 出于安全等因素的考虑，具体操作方式不在开放平台上公开，感兴趣的朋友可在《重学安卓》专栏 特供的同款文章 中阅读到完整原文。 综上人类是基于认知来行动的生物， 现实中 没有过去和未来，只有当下：活在当下就是踩高频、练好基本功。 最高频的现象是自利 —— 人的一切行为都是自利的：来了，就是来利己的，来了还损人的，就是损人利己的。 损人者为了利己、并且为了心安，而 采取损人的方式来自我暗示 —— 掩耳盗铃 —— 通过让他人 “被” 低人一等、“被” 作为奴隶，来使自己的利己行为变得合理， 而当事人若没有对 损人利己 这个情况的确知在先，就会无意识地 不受控制地陷入 自我认知被扭曲的漩涡，陷在里面 感受不舒服和迷思，或者直接 原地爆炸、张弓拔弩。 所以，通过对 损人利己 情况的确知，我们得以对同类事情有 确定感，能在事情发生时 条件反射级地 予以拦截和恢复关系平等 —— “哦，他来侵犯了。” —— 对方在你心目中的分量不再被放大，而是被归位为原有的、微不足道的一小点。这样的关系没用，你知道了，他对你一点用也没有，他就是来索取的，你无法从他身上交换到任何好处。 并且也不再点开那些热点，什么 Papi 酱被女权狂喷，什么什么什么什么 …… 阳光底下无新鲜事，用膝盖想也知道，十有八九是 某些人在生活中 权益受侵犯还不确知，转而到网络上 利用躲在暗处的地位优势来 迁怒于人 （最常见的套路就是 恶意曲解、断章取义、带节奏、下定义、扣帽子，然后以此为由去 批斗 某个公众人物或创作者，通过 破坏 他人的正当经营 和 损害 他人的正当权益 来给自己个交代。骂人又不犯法对吧，“法不责众” 对吧，就算一抓一个准，事后也顶多顶多公开道歉对吧，不用承担任何责任对吧） —— 受虐狂同时也会是施虐狂 —— 这些人无非就是 无意识地模仿了 打压过他们的人，并将被打压的愤怒转嫁到其他人身上。所以关于 “网络暴民”，至此你也就能够窥见，其背后 未被揭露的 职场 PUA 或家庭 PUA 的严重和普遍了吧。 （再次明示：网络暴力 - 侮辱 - 指责 - 谩骂 - 攻击，套路无非就是，先将对方描绘成邪恶的、人格上低人一等的、非人般的存在，然后就能 理所当然地随意践踏和侵权、把气全都往这个人身上撒（因为只要“不是人”，就没有权益可言，什么名誉权、隐私权，都没有的，可以绕过良知随意侵犯和支配）—— 这一切都是基于合理化思维的、无意识的、自欺欺人的套路。下属成为职场的出气筒、孩子成为家庭的替罪羊、网友成为被恶毒攻击的对象。） 历史总是一再地重复。3030 年的你，如在网上看到这篇写于 2020 年的古文，不要 太、惊 讶 好了，文章到这里 也就结束了，对过去 13 年 我在 自我认知和心理学上 的专注 也有个交代了。 我相信这个世界上 还有很多很多的优秀作品 尚未发表，就因为当事人 畏于随之而来的评论和攻击。 损人利己，侵犯，权益，无条件地平等，确定感，当下，记住这些就好了。 真正的勇者，是认清了生活的真相，还依然热爱着生活。 就写这么多了，现在轮到你了 —— 这篇文章值得让更多有需要的人接触到 —— 你身边的每个人，都值得和你一样心智独立成熟。 GitHub 开源免疫补丁：https://github.com/KunMinX/PUA-Immunity 本文以 CC 署名-非商业性使用-禁止演绎 4.0 国际协议 发行。 Copyright © 2020-present KunMinX","link":"/2020/05/20/%E5%85%8D%E7%96%AB%E7%BD%91%E7%BB%9C%E6%9A%B4%E5%8A%9B%E5%92%8C%E6%89%93%E5%8E%8B%E7%9A%84%E7%BB%88%E6%9E%81%E8%AE%A4%E7%9F%A5%E8%A1%A5%E4%B8%81/"},{"title":"吐血整理 | Jetpack MVVM 高频提问和解答","text":"很高兴见到你！ 我是《Jetpack MVVM 精讲》和《Jetpack MVVM 最佳实践》的作者 KunMinX， 在过去一年里，我们分别在各渠道的维护和交流中，收集到许多新上手的小伙伴在把 Jetpack MVVM 应用到自己项目中时，最频繁提及的问题， 随着 Jetpack MVVM 的普及，高频提问也越来越多地出现在 面试或重构工作中， 考虑到这些四处分散的 Q&amp;A（提问和解答） 不便于新上手的小伙伴查阅，因而单独准备了本文，点开就能直接查看到 从数百位读者的数千次提问中 精心筛选出的高频 Q&amp;A， 所以这样的文章，从前乃至往后就只提供这么一篇，请珍惜地享用 😉 &nbsp; 目录一览 《重学安卓》读者群 高频 Q&amp;A TOP 5 TOP 1：Jetpack MVVM 下的页面通信怎么做？ TOP 2：LiveData “数据倒灌” 是什么情况，如何解决？ TOP 3：逻辑为什么不在 ViewModel 中写？ TOP 4：为什么不用 LiveDataBus？ TOP 5：Navigation replace 方式返回时，怎么恢复视图状态？ 《最佳实践》项目 issue 区 高频 Q&amp;A TOP 5 TOP 1：页面 onPause 的时候，不是不该收到消息吗？ TOP 2：《最佳实践》项目中的 “DataBinding 严格模式” 是怎么回事？ TOP 3：绑定视图状态，LiveData 和 ObservableField，怎么取舍？ TOP 4：LiveData observe 回调走了多次，该如何处理？ TOP 5：将《最佳实践》的 Navigation 修改版引入到自己项目，结果还是走的 replace，怎么办？ &nbsp; 《重学安卓》读者群 高频 Q&amp;A TOP 5&nbsp; TOP 1：Jetpack MVVM 下的页面通信怎么做？解答：通过 SharedViewModel 来完成。 追问：为什么？ 解答：我们之所以选择 Application 级的 ViewModel，而不是静态变量或传统 bus 来完成 应用内页面间的消息通信（事件回调等），是考虑到： 1.该 ViewModel 被封装在视图控制器（Activity/Fragment）的基类，使得消息能够 仅限于在视图控制器之间传播，而不污染到之外的区域。 2.同时也可避免被外部的组件拿到，而造成不可预期的推送。 具体可见《最佳实践》项目中对 SharedViewModel 的使用。 &nbsp; TOP 2：LiveData “数据倒灌” 是什么情况，如何解决？解答：“数据倒灌” 现象是我全网首创的对某类现象的概括，所以网上大概搜不到这类描述。 数据倒灌是 专指 在 页面通信（事件回调）的场景下，通过 SharedViewModel 的 LiveData 给当前页通知过一次，并返回上一页，下次再进入当前页时重复收到推送的情况。 目前《最佳实践》项目中通过 EventLiveData 解决了这类问题，具体可查看最新源码。 Event 包装器 重写底层 EventLiveData &nbsp; TOP 3：逻辑为什么不在 ViewModel 中写？解答：Jetpack MVVM 主要遵循 数据驱动 和 关注点分离 这两大特性， 其中关注点分离 是通过 “最小知道原则” 来体现： UI 逻辑在视图控制器（Activity / Fragment）中写， 业务逻辑在数据层（例如 DataRepository）写。 ViewModel 作为 视图控制器 和 数据层 沟通的桥梁，其自身应保持轻量，以胜任 “承上启下” 的角色（保持整体框架的 单向依赖）。 而且，就像认识其他问题一样，“逻辑该在 Activity 中写还是 ViewModel 中写”， 要搞清楚这个问题，我们 仍然需要首先搞清楚，这件事的背景是什么 —— 是在多人协作的软件工程的背景下。 👆👆👆 划重点 这意味着什么呢？意味着，一旦 你将 UI 逻辑放在 ViewModel 中写了，后续就不可控了， 你的同事如果不熟悉这一套开发模式，在 “破窗效应” 的驱使下，就可能直接在 ViewModel 中取 context、取各种不该取的东西，最终内存泄漏什么的，全都来了。 综上，ViewModel 的职责边界就是帮助 Activity/Fragment 托管数据，不适合在 ViewModel 中写逻辑。 更多细节内容详见 《有了 Jetpack ViewModel . . . 真的可以为所欲为！》 中的介绍。 &nbsp; TOP 4：为什么不用 LiveDataBus？解答：原因同上。 不使用 LiveDataBus 是因为，我们是以 在 多人协作、页面繁杂的 软件工程 为背景来谈论架构设计的。在这样的背景下，任何微不足道的隐患，都可能被无限放大。 bus 自身 缺乏唯一可信源的理念约束 以及 难以追溯事件源对象，应彻底从项目中移除，以免团队新手的误用乃至滥用。 具体缘由可参考 《LiveData 鲜为人知的 身世背景 和 独特使命》 中的介绍。 与此同时，尽可能使用 单例或全局 ViewModel 来托管 liveData，这样调试时能根据内存中的 liveData 对象找到事件源。LiveDataBus 这种通过 tag 来标记的，难以找到。 &nbsp; TOP 5：Navigation replace 方式返回时，怎么恢复视图状态？解答：Navigation 的 FragmentNavigator，官方写法是通过 replace 来启动新 Fragment，这可能造成返回时重绘页面等问题，对此有两种办法，一种是重写 FragmentNavigator，使之通过 show hide 来启动新 Fragment，另一种是在 onCreateView 中复用上一次实例化好的 View。 具体操作和注意事项可参考 《就算不用 Jetpack Navigation，也请务必领略的声明式编程之美！》 文末的详细补充，以及我和 Flywith24 在 《我的碎片很听话，你的 Fragment 有自己的想法》 评论区 22 楼关于 replace 方式返回时视图状态恢复的讨论。 &nbsp; Jetpack MVVM 最佳实践 issue 高频 Q&amp;A TOP 5：&nbsp; TOP 1：页面 onPause 的时候，不是不该收到消息吗？解答：看到网上有不少 以讹传讹的网文 传播 “页面 onPause 时不会收到 LiveData 通知” 等不实观点，给读者们徒添困扰、耽误大量时间，特此辟谣： 事实恰恰相反，onPause 可以收到，而 onStart 不是所有场景都能收到（截至 2020.2，Activity 能，Fragment 不能） —— 只有 onResume 和 onPause 是介于 STARTED、RESUMED 状态之间，也即只有这两个生命周期节点 100% 确定能够收到 LiveData 的推送。 具体缘由详见专栏 《为你还原一个真实的 Jetpack Lifecycle》 文末 最新补充 &nbsp; TOP 2：《最佳实践》项目中的 “DataBinding 严格模式”是怎么回事？解答：“严格模式” 是我基于对 “数据驱动” 的本质的理解，而全网首创的 软件工程安全的 “纯粹数据驱动” 的写法。换言之，只要遵循 “严格模式”，就可以确保 100% 解决视图调用的一致性问题（安全性等价于基于函数式编程思想的 Jetpack Compose），避免在多布局等背景下滋生的各种 null 安全情况的发生。 关于 “数据驱动” 的本质，可详见 《从 被误解 到 真香 的 Jetpack DataBinding！》 和 《是 事关软件工程安全 的 数据驱动 UI 框架 上车指南》 中全网独家提供的深度解析。 &nbsp; TOP 3：为什么 MainActivityViewModel 中使用 LiveData 绑定视图状态，而其他 State-ViewModel 使用 ObservableField？解答：ObservaleField 有防抖的特点，要记住这个特点，然后根据情况选择使用。 比如 PureMusic 中通知抽屉打开，用 ObservaleField&lt;Boolean&gt; 不合适，而 LiveData 合适，因为 ObservaleField 防抖，第一次 set true，就有 true 为 value 了，第二次再 set true，就不 notify 视图刷新了（具体见 ObservaleBoolean 的 set 方法实现） 防抖可以避免重复刷新 以减少不必要的性能开销，所以看情况选择 ObservaleField 或 LiveData。 更多细节内容详见 《从 被误解 到 真香 的 Jetpack DataBinding！》 文末及评论区中的补充。 &nbsp; TOP 4：LiveData observe 回调走了多次，该如何处理？解答：（注意此处所指的情况不同于 “数据倒灌”） 考虑到此前有多位小伙伴私下询问过 LiveData “重复回调”的问题，这里额外做个明示： LiveData 是被设计为，支持从 ViewModel、单例等唯一可信源 完成数据的一对多分发，因而其内部的观察套路 并非 “一对一”的 观察者模式，而是 “一对多” 的 发布-订阅模式，我在 2018 年初自主设计并开源的 VIABUS 架构 也是采取这种模式，内部通过 Map 来维护订阅者。 所以正常情况下，对于 一个 LiveData 实例，在同一个页面中只该注册一次观察、请勿在 RecyclerView Adapter 的 onBindViewHolder 等处注册，避免导致重复注册多个订阅者，从而不可预期地在每次请求后 “收到多次推送”。 更多完整的提示可参见 《LiveData 鲜为人知的 身世背景 和 独特使命》 文末的最新补充。 &nbsp; TOP 5：将《最佳实践》的 Navigation 修改版引入到自己项目，结果还是走的 replace，怎么办？解答：请移除自己项目中引入的 navigation.fragment gradle 引用，不然可能会覆盖来自 architecture module 下的那些。并且，请确保 navigation.fragment 被移入自己项目时，和原来 architecture module 中一样，使用完整的 com.androidX 的包名路径。 &nbsp; 版权声明本文以 CC 署名-非商业性使用-禁止演绎 4.0 国际协议 发行。 Copyright © 2019-present KunMinX 本文内容均属于作者 KunMinX 原创，转载须遵守上述协议，保证原文内容的完整、注明作者及出处。 任何个人或组织，未经作者本人沟通许可，不得将文中内容洗稿和用于写书、卖课等商业活动。","link":"/2020/06/14/%E5%90%90%E8%A1%80%E6%95%B4%E7%90%86%20%7C%20Jetpack%20MVVM%20%E9%AB%98%E9%A2%91%E6%8F%90%E9%97%AE%E5%92%8C%E8%A7%A3%E7%AD%94/"}],"tags":[],"categories":[]}