{"posts":[{"title":"","text":"像看待新冠病毒一样，我们逐渐学会长期与 “来自他人的恶意” 共处。 以下是截至目前，结合多领域视角所构建的理解： 设定如此，故高频且普遍人是生物，生物是基因载体，基因的演化迭代机制，使其默认隐含对优越性的追求，因而人本就有优越感需求， 超脱优越感毕竟难事，因而定力较弱的一部分人，出于生物节能本能，无一例外摸索出 “最低成本、最短路径” —— 通过 “语言霸凌、网络暴力、逞口舌之快” 等方式秀优越， 常见套路即，动辄臆想和放大某杠点（例如 阴谋、愚蠢、不够、不公），然后拿着这杠点去抬杠锤人，期间自动占据了道德制高点、彰显了正义和优越、获得 “来得快” 的情绪爽感/心理收益， 由于 “占理” 和 “道德” 已沦为 “彰显优越感乃至嘴爽” 的工具，因而这里面再没有什么道理和道德，怎么容易怎么来， 你会发现，那些动辄针对某个人及其作品的抬杠，本身多是从臆想出发的无端指责，通过各种言外之意暗讽，通过其个人的偏见以偏概全，这与你亲历的付出、拥护的事实、期待的反馈产生冲突，于是容易构成你的心理不平衡、产生负面情绪困扰、乃至做出不理智回应。 平等独立，和而不同理解了外部因素，再来了解下内部因素。 之所以在意别人的碎嘴、容易被带节奏的偏见声影响，是因为潜意识深处认定 “真相只能有一个”，乃至潜意识自动推导出 “如果别人是对的，我就一定是错的”、“如果别人有发声，那他说的就是真的” 等荒谬结论， 而抬杠者为了彰显，恰恰又喜欢 “装模作样 居高临下” 来欺弄人， 为此，只要别人 “偷梁换柱 颠倒是非”，你便容易心理失衡，感到耻辱或危机 —— 就好像，它说什么就是什么，它怎么都有理，然后消耗的全是你， 那么，既然这结构不合理，修正便是 —— “真相和真理是个多面体，不具唯一性和绝对性” —— 每个人都只能从某个角度出发看到 “真” 的某个面，无论其 “狐假虎威” 装的有多逼真、观点有多绝对，所陈述的观点依然只代表其个人、顶多是代表其同类，而非全人类，更不至于是客观完整的 “真” 本身， 由此，不再过度在意有的没的 —— “你可以有你的观点，我不在意你到底什么观点，我也可以有我的观点，我保持我观点的独立，不寻求认同，也不接受征服”， —— 众生平等，没有利害，没有失衡，没有困扰，没有索求，也没有妥协。 本自具足，而无需彰显。 版权声明 Copyright © 2019-present KunMinX 原创版权所有。 如需 转载本文，或引用、借鉴 本文 “引言、思路、结论、配图” 进行二次创作发行，须注明链接出处，否则我们保留追责权利。","link":"/2022/12/26/%E8%AE%BA%E6%8F%90%E7%BA%BF%E6%9C%A8%E5%81%B6%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"},{"title":"","text":"前言最近后台时而收到读者留言，说能否出一期 Jetpack MVVM 精讲，以及配套一份简练案例，好把玩把玩、感受感受、加深 MVVM 印象。 答案是肯定的。 面向标准化开发已成现实金九银十，相信不少读者在抓紧机会面试。 Android 市场已今非昔比。过去迫于招人压力，应试者只需了解四大组件、视图、网络请求，即可谋得一份满意工作。 现如今，Jetpack 架构组件及 “标准化开发模式” 确立，预示 Android 开发已步入成熟阶段： 许多 “样板代码” 不再需开发者手写，而是可通过 “模版工具” 自动生成，在取缔繁杂耗时重复工作同时，避免因 “人工操作疏忽” 造成难以排查、不可预期错误。 这十分符合企业利益，因而面试官招人时，也更加看重应试者对架构组件 —— 至少是 MVVM 理解程度。 像 “解耦” 等含糊其辞说法，不再为面试官认可，稍有 MVVM 经验面试官，都会请你举例说明，好证实你对 MVVM 确有深入理解，能自然而然写出标准化、规范化代码，能迅速适应各公司自制 “自动化模版工具”。 本文目标本人拥有 3 年 “移动端架构” 践行和设计经验，领导或参与团队 “重构” 中大型项目多达十数个，对 Jetpack MVVM 架构在 “确立规范化、标准化开发模式，以减少不可预期错误” 所作努力，有深入理解。 因而本文目标，就是结合前几期我们分别 “深入浅出” 介绍的 Lifecycle、LiveData、ViewModel、DataBinding 来融汇贯通演绎一下： 作为 “应用开发骨架” 的 “标准化状态管理框架”，究竟为快速开发过程中 “减少不可预期错误” 做了哪些努力。 不同于 “东拼西凑、人云亦云、徒添困扰” 网文，愿意将标准化开发模式 深度思考知识 和 实战反思经验 无保留分享，全网仅此一家。这样文章可以说 看一篇、少一篇，因此，就算不去 hold 住面试官，也请务必跟随本文脚步，将 Jetpack MVVM 来龙去脉过一遍。 文章目录一览 前言 面向标准化开发已成现实 本文目标 Jetpack Lifecycle Lifecycle 存在前的混沌世界 Lifecycle 为什么能解决上述这些问题？ Jetpack LiveData LiveData 存在前的混沌世界 LiveData 为什么能解决上述这些问题？ LiveData 有个坑需要注意 Jetpack ViewModel ViewModel 存在前的混沌世界 ViewModel 为什么能做到这几点？ Jetpack DataBinding DataBinding 存在前的混沌世界 DataBinding 就是来解决这些问题 综上 Jetpack Lifecycle Lifecycle 的存在，主要为了解决 “生命周期管理” 一致性问题 Lifecycle 存在前的混沌世界Lifecycle 面市前，“生命周期管理” 纯靠手工维持，这容易滋生大量一致性问题。 例如跨页面共享 GpsManager 组件，在每个宿主 Activity 的 onResume 和 onPause 中都需 手动 “激活、解绑 和 叫停”。 那么 随着宿主 Activity 增多，这种手动操作埋下的 “一致性隐患” 就会指数级增长： 一方面，凡需手工维持，开发者皆易疏忽，特别是工作交接给其他同事时，同事并不能及时注意到这些细节。 另一方面，分散的代码不利于修改，日后除了激活、叫停，若有其他操作补充，则每个宿主 Activity 都需额外书写一遍。 Lifecycle 为何能解决上述这些问题？Lifecycle 通过 “模板方法模式” 和 “观察者模式”，将生命周期管理的复杂操作，全在 LifecycleOwner（如 Activity、Fragment 等 “视图控制器” 基类）中封装好，默默在背后为开发者运筹帷幄， 开发者因而得以在 “视图控制器” 子类中只需一句 getLifecycle().addObserver(GpsManager.getInstance) ，优雅完成 “第三方组件” 在自己内部对 LifecycleOwner 生命周期 “感知”。 除解决一致性问题，这么做还 顺带提供其他 2 个好处： 1.规避为 “监听状态” 而注入 “视图控制器” 做法 为监听状态，传统做法是，将 Activity 作为方法参数手工注入，这埋下 “内存泄漏” 隐患 —— 因为团队新手容易因 “这有个 Activity 实例”，而在日后误将其上升为成员变量，并依赖给组件中其他成员。 现如今，我们可直接在组件内部 “点到为止” 监听 LifecycleOwner 状态，从而规避这种不恰当使用。 2.规避为 “追溯事故来源” 而注入 “视图控制器” 做法 发生事故时，传统 追溯事故来源 方式，同是向方法参数直接注入 Activity，这再次埋下 “内存泄漏” 隐患。现如今，三方组件实现 DefaultLifecycleObserver 即可在 “生命周期回调” 方法作用域中 直接根据 LifecycleOwner 参数得知事故源。 如这么说无体会，详见《为你还原一个真实的 Jetpack Lifecycle》 中提供的 GpsManager 案例，本文不再累述。 Jetpack LiveData LiveData 的存在，主要为了 新手老手都能不假思索遵循 “通过唯一可信源分发消息” 标准化开发理念，以便快速开发过程中 “难追溯、难排查、不可预期” 问题发生概率降低到最低。 LiveData 存在前的混沌世界LiveData 面市前，我们在 “网络请求回调、跨页面通信” 等场景分发消息，多是通过 EventBus 或 Java Interface 完成。 那这造成什么问题？首先，EventBus 等 “消息总线” 只是纯粹传话筒，它 缺乏上述 “标准化开发理念” 约束，那么人们使用该框架时，容易因 “去中心化” 滥用，造成诸如 “毫无防备收到预期外、不明来源推送”、拿到过时数据、事件源追溯复杂度放大至 n²。 且，EventBus 本身缺乏 Lifecycle 加持，存在生命周期管理一致性问题。这是 EventBus 硬伤，也是我拒绝使用 EventBus 最主要因素。 如对上述状况无体会，可具体参考我们在 《LiveData 鲜为人知 身世背景 和 独特使命》 中提供的 “播放器状态全局通知” 案例。 LiveData 为何能解决上述这些问题？首先，LiveData 是在 Google 希望确立 “标准化、规范化” 开发模式 背景下诞生，因而为达成该艰巨使命，LiveData 被十分克制设计为，仅支持状态输入和监听，且可基于 “访问权限控制” 来实现 “读写分离”（protected + mutable）。 这使任何一次数据推送，都可被限制为 “只能单方面从唯一可信源推送而来”（也即所谓 “单向数据流”），从而避免消息同步不一致、不可靠、在事件追溯复杂度 n² 迷宫中白费时间， 也即，无论从哪个 “视图控制器” 发起消息请求，结果最终都由作为 “唯一可信源” 的单例或 SharedViewModel 在其内部统一决策、一对多通知。 且，这种承上启下方式，使单向依赖成为可能：单例无需通过 Java Interface 回调通知视图控制器，从而规避 “视图控制器” 被 “生命周期更长的单例” 依赖而埋下内存泄漏隐患。 LiveData 有个坑需要注意不过我个人认为，LiveData 的 Observer 设计缺乏边界感， 作为表现层承担 BehaviorSubject 职能的组件，应避免开发者直接接触 Observer 回调，并确保 “与控件属性一对一绑定”，不然开发者容易将其误用作 “一次性事件分发组件”，造成 “订阅时被自动回推脏数据”；或是开发者误使同一控件实例出现在多个 Observer 回调中，造成《MVI 存在意义》篇 “响应式编程漏洞” 一节所说的 “数据一致性” 问题， 经过广泛实践，发现 DataBinding 的 ObservableFiled 能做到 “与控件属性一对一绑定” 从而完美胜任表现层 BehaviorSubject 工作，因而最终决定将 LiveData 往领域层 “一次性数据分发” 的方向改造为 UnPeekLiveData，使其专职 PublishSubject， 当然，由于 LiveData 存在的初衷并非是专业的 “一次性事件分发组件”，改造过的 UnPeekLiveData 也只适用于 “低频次数据分发（例如每秒推送 1 次）” 场景， 因而若想满足 “高频次事件分发” 需求（例如每秒推送 5 次以上），请改用或参考专职 “领域层” 数据分发的 MVI-Dispatcher 组件，该组件内部通过消息队列设计，确保不漏掉每一次推送。 注：BehaviorSubject 和 PublishSubject 是 “响应式编程” 领域的概念，具体可参考《MVI 存在意义》篇 的解析 Jetpack ViewModel ViewModel 的存在，主要为了解决 “状态管理” 和 “页面通信” 问题。 ViewModel 存在前的混沌世界ViewModel 本职工作是 状态托管 和 状态管理 “分治”，也即当视图控制器重建时， 对于轻量状态，可通过 “视图控制器” 基类 saveInstanceState 机制，以序列化方式完成存储和恢复。 对于重量级状态，例如通过网络请求得到的 List，可通过生命周期长于视图控制器的 ViewModel 持有，从而得以直接从 ViewModel 恢复，而不是以效率较低的序列化方式。 在 Jetpack ViewModel 面市之前，MVP 的 Presenter 和 MVVM - Clean 的 ViewModel，由于生命周期短于视图控制器，它们顶多为 DataBinding 提供状态托管，而无法实现状态分治。 到了 Jetpack 这版，ViewModel 以精妙设计，达成状态管理，及可共享作用域。 ViewModel 为何能做到这几点？其实这版主要基于 工厂模式，使 ViewModel 被 LifecycleOwner 所持有、通过 ViewModelProvider 来引用， 所以 它既类似于单例：—— 当被作为 LifecycleOwner 的 Activity 持有时，能脱离 Activity 旗下 Fragment 生命周期，从而实现作用域共享， 实际上又不是单例：—— 生命周期跟随作为 LifecycleOwner 的视图控制器，当 Owner（Activity 或 Fragment）被销毁时，它也被 clear。 此外，出于对视图控制器 “重建” 考虑，Google 在视图控制器基类中通过 retain 机制对 ViewModel 进行保留。 因此，对于 “作用域共享” 和 “视图重建” 情况，状态因完好被保留，而得以被视图控制器在恢复时直接使用。 再者，由于存在 “共享作用域” 考虑，ViewModel 本身也承担了跨页面通信职责。此场景下 LiveData “数据倒灌” 问题，上文已介绍，不再累述。 Note：截至 2020.2.1，ViewModel 在 Fragment 中 retain 设计已发生剧变，具体缘由可参考我们在 《页面开发 左右逢源 Jetpack ViewModel》 文末及评论区最新补充。 Jetpack DataBinding DataBinding 的存在，主要为了解决 “View 实例 Null 安全” 一致性问题。 DataBinding 存在前的混沌世界DataBinding 面市前，我们若要改变视图状态，唯有先调用该 View 实例，如 textView.setText( )， 这造成什么问题？ 当页面存在横、竖布局，且两种布局控件存在差异，例如横屏存在 textView 控件，而竖屏没有，那么我们便不得不在 “视图控制器” 中为 textView 做判空处理，这就造成一致性问题 —— 容易疏忽而忘记判空，毕竟页面多达数十个、每个页面调用控件的地方也无数。 那怎么办？ DataBinding 就是来解决这些问题通过让 “控件” 与 “可观察数据” 发生绑定，那么当该数据被 set 新内容时，被绑定该数据的控件即可被通知和刷新。 Note 2020.4.18：这一切都是 “编译时自动生成中间代码” 在背后完成的逻辑衔接，也即控件如存在于布局中（例如竖屏布局中）且绑定了可观察数据，就会被调用和通知，如不存在（例如横屏布局中），就没被调用，无论哪一种情况，都不至于发生 Null 安全一致性问题。 换言之，使用 DataBinding 后，唯一的改变是，你无需 “手工调用 View 实例” 来 set 新状态，你只需 set 可观察数据本身。 因而，DataBinding 并非许多人不假思索认为的，将 UI 逻辑搬到 XML 中写、从而难以调试 —— 事实并非如此： DataBinding 只负责绑定数据、负责 “作为 UI 逻辑末端状态” 的改变（也即它是一个不可再分原子操作，本就不需调试），原本在视图控制器中 UI 逻辑怎么写，现还是怎么写，只不过不再需要 textView.setText(xxx)，而是直接 xxx.set( )。 所以在 DataBinding 帮助下，好处总共多少个？ 1.规避 View 实例 Null 安全一致性问题 —— 无需手工判空。 2.规避 View 实例 Null 安全一致性问题，乃至无需手动调用 View，从而完全不用写 findViewById。 3.就算要调用 View，也不用 findViewById，而是直接通过 mBinding 调用。 4.先前 UI 逻辑基本不用改动，改的只是 “改变末端状态” 方式。 …… 此外，DataBinding 有个大杀器：能为控件提供自定义属性的 BindingAdapter，它不仅可解决圆角 Drawable 复用问题，还可实现 imageView 直接绑定 url 等需求，总之，没有它办不到，只有你想不到，DataBinding 好处等着你挖掘。 关于 DataBinding 注意事项、屡试不爽排坑技巧，以及独家解析 “DataBinding 严格模式”，可具体参考 《从被误解到 “真香” Jetpack DataBinding》，这里不做累述。 综上Lifecycle 的存在，主要为了解决 “生命周期管理” 一致性问题。 LiveData 的存在，主要为了实现 “消息分发可靠一致”。 ViewModel 的存在，主要为了解决 “状态管理” 一致性问题。 DataBinding 的存在，主要为了解决 “View 实例 Null 安全” 一致性问题。 它们的存在，大都为在 “软件工程” 背景下解决一致性问题、将易出错操作封装于后台，方便使用者 “快速、稳定、不产生预期外错误” 编码。 全文完 本文配套项目 GitHub : Jetpack-MVVM-Best-Practice 版权声明本文以 CC 署名-非商业性使用-禁止演绎 4.0 国际协议 发行。 Copyright © 2019-present KunMinX 文中提到的 “xxx 架构组件的存在，是为了在 多人协作软件工程背景下 解决 xxx 一致性问题”，以及 “LiveData 在页面通信、事件回调场景下发生 数据倒灌” 等多处 对特定现象及其本质匹配和概括，均属于本人独立原创成果，本人对此享有所有权和最终解释权。 当您借鉴或引用本文 引言、思路、结论进行二次创作，或全文转载时，须注明链接出处，否则我们保留追责权利。 未经与作者本人当面沟通许可，不得将文章内容用于洗稿、广告包装等商业用途。","link":"/2019/10/23/%E8%80%B3%E7%9B%AE%E4%B8%80%E6%96%B0%20Jetpack%20MVVM%20%E7%B2%BE%E8%AE%B2/"},{"title":"","text":"学技术要学本质。对 MVI 的有效理解，源于对 “响应式编程 作用和漏洞” 等关键细节的挖掘， 故这期专为 MVI 打磨一篇 “通俗易懂、看完便理解来龙去脉、并能活学活用”，相信阅读后你会耳目一新。 文章目录一览 前言 响应式编程 响应式编程的好处 响应式编程的漏洞 响应式编程的困境 MVI 的存在意义 MVI 的实现 函数式编程思想 MVI 怎样实现纯函数效果 存在哪些副作用 整体流程 当下开发现状的反思 从源头把问题消灭 什么是过度设计，如何避免 平替方案的探索 综上 响应式编程谈到 MVI，首先要提的是 “响应式编程”，响应式是 Reactive 翻译成中文叫法，对应 Java 语言实现是 RxJava， ReactiveX 官方对 Rx 框架描述是：使用 “可观察流” 进行异步编程的 API， 翻译成人话即，响应式编程暗示人们 应当总是向数据源请求数据，然后在指定的观察者中响应数据的变化， 常见的 “响应式编程” 流程用伪代码表示如下： 响应式编程的好处通过上述代码易得，在响应式编程下，业务逻辑在 ViewModel / Presenter 处集中管理，过程中向 UI 回推状态，且 UI 控件在指定的 “粘性观察者” 中响应，该模式下很容易做单元测试，有输入必有回响。 反之如像往常一样，将控件渲染代码分散在观察者以外的各个方法中，便很难做到这一点。 响应式编程的漏洞随着业务发展，人们开始往 “粘性观察者” 回调中添加各种控件渲染， 如果同一控件实例（比如 textView）出现在不同粘性观察者回调中： 123456789livedata_A.observe(this, dataA -&gt; textView.setText(dataA.b) ...}livedata_B.observe(this, dataB -&gt; textView.setText(dataB.b) ⚠️ ...} 假设用户操作使得 textView 先接收到 liveData_B 消息，再接收到 liveData_A 消息， 那么旋屏重建后，由于 liveData_B 的注册晚于 liveData_A，textView 被回推的最后一次数据反而是来自 liveData_B， 给用户的感觉是，旋屏后展示老数据，不符预期。 响应式编程的困境由此可得，响应式编程存在 1 个不显眼的关键细节： 一个控件应当只在同一个观察者中响应，也即同一控件实例不该出现在多个观察者中。 但如果这么做，又会产生新的问题。由于页面控件往往多达十数个，如此观察者也需配上十数个。 是否存在某种方式，既能杜绝 “一个控件在多个观察者中响应”，又能消除与日俱增的观察者？答案是有 —— 即接下来我们介绍的 MVI。 MVI 的存在意义MVI 是 在响应式编程的前提下，通过 “将页面状态聚合” 来统一消除上述 2 个问题， 也即原先分散在各个 LiveData 中的 String、Boolean 等状态，现全部聚合到一个 JavaBean / data class 中，由唯一的粘性观察者回推，所有控件都在该观察者中响应数据的变化。 具体该如何实现？业界有个简单粗暴的解法 —— 遵循 “函数式编程思想”。 MVI 的实现函数式编程思想函数式编程的核心主要是纯函数，这种函数只有 “参数列表” 这唯一入口来传入初值，只有 “返回值” 这唯一出口来返回结果，且 “运算过程中” 不调用和影响函数作用域外的变量（也即 “无副作用”）， 123456789101112131415int apublic int calculate(int b){ //纯函数 return b + b}public int changeA(){ //非纯函数，因运算过程中调用和影响到外界变量 a int c = a = calculate(b) return c}public int changeB() { //纯函数 int b = calculate(2) return b + 1} 显而易见，纯函数的好处是 “可以闭着眼使用”，有怎样的输入，必有怎样的输出，且过程中不会有预料外的影响发生。 这里贴一张网上盛传的图来说明 Model、View、Intent 三者关系， 笔者认为，MVI 并非真的 “纯函数实现”，而只是 “纯函数思想” 的实现， 也即我们实际上都是以 “面向对象” 方式在编程，从效果上达到 “纯函数” 即可， 反之如钻牛角尖，看什么都 “有副作用、不纯”，则易陷入悲观，忽视本可改善的环节，有点得不偿失。 MVI 怎样实现纯函数效果 Model 通常是继承 Jetpack ViewModel 来实现，负责处理业务逻辑； Intent 是指发起本次请求的意图，告诉 Model 本次执行哪个业务。它可以携带或不带参数； View 通常对应 Activity/Fragment，根据 Model 返回的 UiStates 进行渲染。 也即我们让 Model 只暴露一个入口，用于输入 intent；只暴露一个出口，用于回调 UiStates；业务执行过程中不影响 UiStates 以外的结果；且 UiStates 的字段都设置为不可变（final / val）确保线程安全，即可达成 Model 的 “纯”， Intent 达成 “纯” 比较简单，由于它只是个入参，字段都设置为不可变即可。 View 同样不难，只要确保 View 的入口就是 Model 的出口，也即 View 的控件都集中放置在 Model 的回调中渲染，即可达成 “纯”。 存在哪些副作用存在争议的副作用 那有人可能会说，“不对啊，View 在入口中调用了控件实例，也即函数作用域外的成员变量，是副作用呀” …… 笔者认为这是误解， 因为 MVI 的 View 事实上就不是一个函数，而是一个类。如上文所述，MVI 实际上是 通过面向对象编程的方式实现 “纯函数” 效果，而非真的纯函数， 故我们可以站在类的角度重新审视 —— 控件是类成员，对应的是纯函数的自动变量， 换言之，控件渲染并没有调用和影响到 View 作用域外的元素，故不算副作用。 公认的副作用与此同时，UiEvents 属于副作用，也即那些弹窗、页面跳转等 “一次性消费” 的情况， 为什么？笔者认为 “弹窗、页面跳转” 时，在当前 MVI-View 页面之外创建了新的 Window、或是在返回栈添加了新的页面，如此等于调用和影响了外界环境，所以这必是副作用， 不过这是符合预期的副作用，对此官方 Guide 也有介绍 “将 UiEvents 整合到 UiStates” 的方式来改善该副作用：界面事件 | Android 开发者 | Android Developers 与之相对的即 “不符预期的副作用” —— 例如控件实例被分散在观察者外的各个方法中，并在某个方法中被篡改和置空，其他方法并不知情，调用该实例即发生 NullPointException。 整体流程至此 MVI 的代码实现已呼之欲出： 1.创建一个 UiStates，反映当前页面的所有状态。 12345data class UiStates { val weather : Weather, val isLoading : Boolean, val error : List&lt;UiEvent&gt;,} 2.创建一个 Intent，用于发送请求时携带参数，和指明当前想执行的业务。 123sealed class MainPageIntent { data class GetWeather(val cityCode) : MainPageIntent()} 3.执行业务的过程，总是先从数据层获取数据，然后根据情况分流和回推结果，例如请求成功，便执行 Success 来回推结果，请求失败，则 Error，对此业内普遍的做法是，增设一个 Actions， 并且由于 UiStates 的字段不可变，且控件集中响应 UiStates，也即务必确保 UiStates 的延续，由此每个业务带来局部改变时（partialChange），需通过 copy 等方式，将上一次的 UiStates 拷贝一份，并为对应字段注入 partialChange。这个过程业内称为 reduce。 12345678910111213sealed class MainPageActions { fun reduce(oldStates : UiStates) : UiStates { return when(this){ Loading -&gt; oldStates.copy(isLoading = true) is Success -&gt; oldStates.copy(isLoading = false, weather = this.weather) is Error -&gt; oldStates.copy(isLoading = false, error = listOf(UiEvent(msg))) } } object Loading : MainPageActions() data class Success(val weather : Weather) : MainPageActions() data class Error(val msg : String) : MainPageActions()} 4.创建当前页面使用的 MVI-Model。 123456789101112131415161718192021class MainPageModel : MVI_Model&lt;UiStates&gt;() { private val _stateFlow = MutableStateFlow(UiStates()) val stateFlow = _stateFlow.asStateFlow private fun sendResult(uiStates: S) = _stateFlow.emit(uiStates) fun input(intent: Intent) = viewModelScope.launch{ onHandle() } private suspend fun onHandle(intent: Intent) { when(intent){ is GetWeather -&gt; { sendResult(MainPageActions.Loading.reduce(oldStates) val response = api.post() if(response.isSuccess) sendResult( MainPageActions.Success(response.data).reduce(oldStates) else sendResult( MainPageActions.Error(response.message).reduce(oldStates) } } }} 5.创建 MVI-View，并在 stateFlow 中响应 MVI-Model 数据。 控件集中响应，带来不必要的性能开销，需要做个 diff，只响应发生变化的字段。 笔者通常是通过 DataBinding ObservableField 做防抖。后续如 Jetpack Compose 普及，建议是使用 Jetpack Compose，无需开发者手动 diff，其内部类似前端 DOM ，根据本次注入的声明树自行在内部差分合并渲染新内容。 1234567891011121314151617181920class MainPageActivity : Android_Activity(){ private val model : MainPageModel private val views : MainPageViews fun onCreate(){ lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { model.stateFlow.collect {uiStates -&gt; views.progress.set(uiStates.isLoading) views.weatherInfo.set(uiStates.weather.info) ... } } model.input(Intent.GetWeather(BEI_JING)) } class MainPageViews : Jetpack_ViewModel() { val progress = ObservableBoolean(false) val weatherInfo = ObservableField&lt;String&gt;(&quot;&quot;) ... }} 整个流程用一张图表示即： 当下开发现状的反思上文我们追溯了 MVI 来龙去脉，不难发现，MVI 是给 “响应式编程” 填坑的存在，通过状态聚合来消除 “不符预期回推、观察者爆炸” 等问题， 然而 MVI 也有其不便之处，由于它本就是要通过聚合 UiStates 来规避上述问题，故 UiStates 很容易爆炸，特别是字段极多情况下，每次回推都要做数十个 diff ，在高实时场景下，难免有性能影响， MVI 许多页面和业务都需手写定制，难通过自动生成代码等方式半自动开发，故我们我们不如退一步，反思下为什么要用响应式编程？是否非用不可？ 穷举所有可能，笔者觉得最合理的解释是，响应式编程十分便于单元测试 —— 由于控件只在观察者中响应，有输入必有回响， 也是因为这原因，官方出于完备性考虑，以响应式编程作为架构示例。 从源头把问题消灭现实情况往往复杂。 Android 最初为了站稳脚跟，选择复用已有的 Java 生态和开发者，乃至使用 Java 作为官方语言，后来 Java 越来越难支持现代化移动开发，故而转向 Kotlin， Kotlin 开发者更容易跟着官方文档走，一开始就是接受 Flow 那一套，且 Kotlin 抹平了语法复杂度，天然适合 “响应式编程” 开发，如此便有机会踩坑，乃至有动力通过 MVI 来改善。 然而 10 个 Android 7 个纯 Java ，其中 6 个从不用 RxJava ，剩下一个还是偶尔用用 RxJava 的线程调度切换，所以响应式编程在 Android Java 开发者中的推行不太理想，领导甚至可能为了照顾多数同事，而要求撤回响应式代码，如此便很难有机会踩坑，更谈不上使用 MVI， 也因此，实际开发中更多考虑的是，如何从根源上避免各种不可预期问题。 对此从软件工程角度出发，笔者在设计模式原则中找到答案 —— 任何框架，只要遵循单一职责原则，便能有效避免各种不可预期问题，反之过度设计则易引发不可预期问题。 什么是过度设计，如何避免上文提到的 “粘性观察者”，对应的是 BehaviorSubject 实现，强调 “总是有一个状态”，比如门要么是开着，要么是关着，门在订阅 BehaviorSubject 时，会被自动回推最后一次 State 来反映状态。 常见 BehaviorSubject 实现有 ObservableField、LiveData、StateFlow 等。 反之是 PublishSubject 实现，对应的是一次性事件，常见 PublishSubject 实现有 SharedFlow 等。 笔者认为，LiveData/StateFlow 存在过度设计，因为它的观察者是开放式，一旦开了这口子，后续便不可控，一个良好的设计是，不暴露不该暴露的口子，不给用户犯错的机会。 一个正面的案例是 DataBinding observableField，不向开发者暴露观察者，且一个控件只能在 xml 中绑定一个，从根源上杜绝该问题。 平替方案的探索至此平替方案便也呼之欲出 —— 使用 ObservableField 来承担 BehaviorSubject， 也即直接在 ViewModel 中调用 ObservableField 通知所绑定的控件响应，且每个 ObservableField 都携带原子数据类型（例如 String、Boolean 等类型）， 如此便无需声明 UiStates 数据类。由于无 UiStates、无聚合、也无线程安全问题，也就无需再 reduce 和 diff，简单做个 Actions 为结果分流即可。 此时仍属响应式编程，相较经典 MVI，繁琐度大幅缩减，性能有所提升。 综上响应式编程便于单元测试，但其自身存在漏洞，MVI 即是来消除漏洞， MVI 有一定门槛，实现较繁琐，且存在性能等问题，难免同事撂挑子不干，一夜回到解放前， 综合来说，MVI 适合与 Jetpack Compose 搭配实现 “现代化的开发模式”， 反之如追求 “低成本、复用、稳定”，可通过遵循 “单一职责原则” 从源头把问题消除。 相关资料响应式编程：ReactiveX 函数式编程：函数式编程 - 百科 MVI 纯函数图例：Reactive Apps with Model-View-Intent - Part 2: View and Intent 通过 UiStates 管理 UiEvent：界面事件 | Android Developers 平替方案探索：解决 MVI 架构实战痛点 版权声明 Copyright © 2019-present KunMinX 原创版权所有。 如需 转载本文，或引用、借鉴 本文 “引言、思路、结论、配图” 进行二次创作发行，须注明链接出处，否则我们保留追责权利。","link":"/2022/09/20/MVI%20%E7%9A%84%E5%AD%98%E5%9C%A8%E6%84%8F%E4%B9%89/"},{"title":"","text":"谈到 Android 架构，相信谁都能说上两句。从 MVC，MVP，MVVM，再到时下兴起 MVI，架构设计层出不穷。如何为项目选择合适架构，也成常备课题。 由于架构并非空穴来风，每一种设计都有其存在依据。故今天我们一起探寻 “架构演化” 来龙去脉，相信阅读后你会豁然开朗。 文章目录一览 前言 原生架构 原始图形化架构 高频痛点 1：Null 安全一致性问题 原始工程架构 MVC 高频痛点 2：成员变量爆炸 高频痛点 3：状态管理一致性问题 高频痛点 4：消息分发一致性问题 它山之石 矫枉过正 MVP 反客为主 Presenter 简明易用 三方库 拨乱反正 MVVM 曲高和寡 DataBinding 未卜先知 mBinding 力挽狂澜 官方牵头 Jetpack 一举多得 ViewModel 半路杀出 Kotlin 喜闻乐见 ViewBinding 百花齐放 最佳实践 Jetpack MVVM 屏蔽回推 UnPeekLiveData 消息分发 Dispatcher 严格模式 DataBinding 另起炉灶 Compose 综上 原生架构原始图形化架构完整软件服务，通常包含客户端和服务端。 Linux 服务端，开发者通过命令行操作；Android 客户端，面向普通用户，须提供图形化操作。为此，Android 将图形系统设计为，通过客户端 Canvas 绘制图形，并交由 Surface Flinger 渲染。 但正如《过目难忘 Android GUI 关系梳理》所述，复杂图形绘制离不开排版过程，而开发者良莠不齐，如直接暴露 Canvas，易导致开发者误用和产生不可预期错误， 为此 Android 索性基于 “模板方法模式” 设计 View、Drawable 等排版模板，让 UI 开发者可继承标准化模板，配置出诸如 TextView、ImageView、ShapeDrawable 等自定义模板，供业务开发者用。 这样误用 Canvas 问题看似解决，却引入 “高频痛点 1”：View 实例 Null 安全一致性问题。这是 Java 语言项目硬伤，客户端背景下尤明显。 高频痛点 1：Null 安全一致性问题例如某页面有横竖两布局，竖布局有 TextViewA，横布局无，那么横屏时，findViewbyId 拿到则是 Null 实例，后续 mTextViewA.setText( ) 如未判空处理，即造成 Null 安全问题， 对此不能一味强调 “手动判空”，毕竟一个页面中，控件成员多达十数个，每个控件实例亦遍布数十方法中。疏忽难避免。 那怎办？此时 2008 年，回顾历史，可总结为：“同志们，7 年暗夜已开始，7 年后会有个框架，驾着七彩祥云来救你”。 原始工程架构 MVC时间来到 2013，以该年问世 Android Studio 为例， 工程结构主要包含 Java 代码和 res 资源。考虑到布局编写预览需求，Android 开发默认基于 XML 声明 Layout，MVC 形态油然而生， 其中 XML 作 View 角色，供 View-Controller 获取实例和控制， Activity 作 View-Controller 角色，结合 View 和 Model 控制逻辑， 开发者另外封装 DataManager，POJO 等，作 Model 角色，用于数据请求响应， 显而易见，该架构实际仅两层：控制层和数据层， Activity 越界承担 “领域层” 业务逻辑职责，也因此滋生如下 3 个高频痛点： 高频痛点 2：成员变量爆炸成员声明，动辄数十行，令人眼花缭乱。接手老项目开发者，最有体会。 高频痛点 3：状态管理一致性问题View 状态保存和恢复，使用原生 onInstanceStateSave &amp; Restore 机制，开发者容易因 “记得 restore、遗漏 save” 而产生不可预期错误。 高频痛点 4：消息分发一致性问题由于 Activity 额外承担 “领域层” 职责，乃至消息收发工作也直接在 Activity 内进行，这使消息来源无法保证时效性、一致性，易 “被迫收到” 不可预期推送，滋生千奇百怪问题。 EventBus 等 “缺乏鉴权结构” 框架，皆为该背景下 “消息分发不一致” 帮凶。 “同志们，5 年水深火热已过去，再过 2 年，曙光降临” 好家伙，这是提前拿到剧本。既然如此，这 2 年时间，不如放开手脚，引入它山之石试试（就逝世）。 它山之石矫枉过正 MVP这一版对 “现实状况” 判断有偏差。 MVP 规定 Activity 应充当 View，而 Presenter 独吞 “表现层” 逻辑，通过 “契约接口” 与 View、Model 通信， 这使 Activity 职能被严重剥夺，只剩末端通知 View 状态改变，无法全权自治 “表现逻辑”。 反客为主 Presenter从 Presenter 角度看，似乎遵循 “依赖倒置原则” 和 “最小知道原则”，但从关系界限层面看，Presenter 属 “空降” 角色，一切都其自作主张、暗箱操作，不仅 “未能实质解决” 原 Activity 面临上述 4 大痛点，反因贪婪夺权引入更多烂事。 这也是为何，开发过 MVP 项目，都知有多别扭。 简明易用 三方库基于其本质 “依赖倒置原则” 和 “最小知道原则”，更建议将其用于 “局部功能设计”，如 “三方库” 设计，使开发者 无需知道内部逻辑，简单配置即可使用。 Github：Linkage-RecyclerView 我们维护的 “饿了么二级联动列表” 库，即是基于该模式设计，感兴趣可自行查阅。 拨乱反正 MVVM经历漫长黑夜，Android 开发引来曙光。 2015 年 Google I/O 大会，DataBinding 框架面世。 该框架可用于解决 “高频痛点1：View 实例 Null 安全一致性问题”，并跟随 MVVM 模式步入开发者视野。 曲高和寡 DataBinding MVVM 是种约定，双向绑定是 MVVM 特征，但非 DataBinding 本质，故长久以来，开发者对 DataBinding 存在误解，认为使用 DataBinding 即须双向绑定、且在 XML 中调试。 事实并非如此。 DataBinding 是通过 “可观察数据 ObservableField” 在编译时与 XML 中对应 View 实例绑定，这使上文所述 “竖布局有 TextViewA 而横布局无” 情况下，有 TextViewA 即被绑定，无即无绑定，于是无论何种情况，都不至于 findViewById 拿到 Null 实例从而诱发 Null 安全问题。 也即，DataBinding 仅负责通知末端 View 状态改变，仅用于规避 Null 安全问题，不参与视图逻辑。而反向绑定是 “迁就” 这一结构的派生设计，非核心本质。 碍于篇幅限制，如这么说无体会，可参见《从被误解到 “真香” Jeptack DataBinding》解析，本文不再累述。 未卜先知 mBinding除了本质难理解，DataBinding 也有硬伤，由于隔着一层 BindingAdapter，难获取 View 体系坐标等 getter 属性，乃至 “属性动画” 等框架难兼容。 有说 MotionLayout 可破此局，于多数场景轻松完成动画。 但它也非省油灯，不同时支持 Drag &amp; Click，难实现我们 示例项目 “展开面板” 场景。 于是，DataBinding 做出 “违背祖宗” 决定 —— 允许开发者在 Java 代码中拿到 mBinding 乃至 View 实例 … 如此上一节提到的 “改用 ObservableField 的绑定来消除 Null 安全问题” 的努力前功尽弃。 —— 鉴于 App 页面并非总是 “横竖布局皆有”，于是开发者索性通过 “强制竖屏” 扼杀 View 实例 Null 安全隐患，而调用 mBinding 实例仅用于规避 findViewById 样板代码。 至于为何说 mBinding 使用即 “未卜先知”，因为群众智慧多年后即被应验。 力挽狂澜官方牵头 Jetpack时间回到 2017，这年 Google I/O 引入一系列 AAC（Android Architecture Components） 一举多得 ViewModel其中 Jetpack ViewModel，通过支持 View 实例状态 “托管” 和 “保存恢复”， 一举解决 “高频痛点2：成员变量爆炸” 和 “高频痛点 3：状态管理一致性问题”， Activity 成员变量表，一下简洁许多。Save &amp; Restore 样板代码亦烟消云散。 半路杀出 Kotlin并且这时期，Kotlin 被扶持为官方语言，背景发生剧变。 Kotlin 直接从语言层面支持 Null 安全，于是 DataBinding 在 Kotlin 项目式微。 喜闻乐见 ViewBinding千呼万唤，ViewBinding 问世 2019。 如布局中 View 实例隐含 Null 安全隐患，则编译时 ViewBinding 中间代码为其生成 @Nullable 注解，使 Kotlin 开发过程中，Android Studio 自动提醒 “强制使用 Null 安全符”，由此确保 Null 安全一致。 ViewBinding 于 Kotlin 项目可平替 DataBinding，开发者喜闻乐见 mBinding 使用。 百花齐放最佳实践 Jetpack MVVM自 2017 年 AAC 问世，部分原生 Jetpack 架构组件至今仍存在设计隐患， 基于 “架构组件本质即解决一致性问题” 理解，我们于 2019 陆续将 “隐患组件” 改造和开源。 Note 2023.4.25 加餐： 屏蔽回推 UnPeekLiveDataLiveData 是效仿响应式编程 BehaviorSubject 的设计，由于 1.Jetpack 架构示例通常只包含 “表现层” 和 “数据层” 两层，缺乏在 “领域层” 分发数据的工具， 2.LiveData Observer 的设计缺乏边界感， 容易让开发者误当做 “一次性事件分发组件” 来使用，造成订阅时 “自动回推脏数据”； 容易让开发者误将同一控件实例放在多个 Observer 回调中 造成恢复状态时 “数据不一致” 等问题（具体可参见《响应式编程和 MVI》篇 关于 “响应式编程漏洞” 的描述） 3.DataBinding ObservableField 组件的 Observer 能限定为 “与控件一对一绑定”，更适合承担表现层 BehaviorSubject 工作， 4.LiveData 具备生命周期安全等优势， 因此决定将 LiveData 往领域层 PublishSubject 方向改造，去除其 “自动推送最后一次状态” 的能力，使其专职生命周期安全的数据分发。 具体可参见 Github：UnPeek-LiveData 使用。 Note 2023.4.25 加餐： 消息分发 Dispatcher由于 LiveData 存在的初衷并非是专业的 “一次性事件分发组件”，改造过的 UnPeekLiveData 也只适用于 “低频次数据分发（例如每秒推送 1 次）” 场景， 因而若想满足 “高频次事件分发” 需求（例如每秒推送 5 次以上），请改用或参考专职 “领域层” 数据分发的 Github：MVI-Dispatcher 组件，该组件内部通过消息队列设计，确保不漏掉每一次推送。 Dispatcher 的存在解决了 “高频痛点 4：消息分发一致性问题”， 也即通过在领域层设立 “专职业务处理和结果回推” 的 Dispatcher，来将业务处理过程中产生的 Event 或 State，以串流的方式统一从 output 出口回传， 由此表现层页面可根据消息的性质，采取 “一致性执行” 或 “交由 BehaviorSubject 托管状态”。 对此具体可参见《Jetpack MVVM 分层设计解析》篇 解析。 严格模式 DataBinding此外我们明确约定 Java 下 DataBinding 使用原则，确保 100% Null 安全。如违背原则，便 Debug 模式下警告，方便开发者留意。 具体可参见 Github：KunMinX-MVVM 使用。 另起炉灶 Compose回到文章开头 Canvas，为实现 View 实例 Null 安全，先是 DataBinding 框架，但它作为一框架，并不体系自洽，与 “属性动画” 等框架难兼容。 于是出现声明式 UI，通过函数式编程 “纯函数原子性” 解决 Null 安全一致。且体系自洽，动画无兼容问题，学习成本也低于 View 体系。 后续如性能全面跟上、120Hz 无压力，建议直接上手 Compose 开发。 注：关于声明式 UI 函数式编程本质，及纯函数原子性为何能实现 Null 安全一致，详见《一通百通 “声明式 UI” 扫盲干货》，本文不作累述。 综上高频痛点1：Null 安全一致性问题 客户端，图形化，需 Canvas， 为避免接触 Canvas 导致不可预期错误，原生架构提供 View、Drawable 排版模板， 为解决 Java 下 View 实例 Null 安全一致性问题，引入 DataBinding， 但 DataBinding 仅是一框架，难体系自洽， 于是兵分两路，Kotlin + ViewBinding 或 Kotlin + Compose 取代 DataBinding。 高频痛点2：成员变量爆炸 高频痛点3：状态管理一致性问题 引入 Jetpack ViewModel，实现状态托管和保存恢复。 高频痛点4：消息分发一致性问题 引入 Dispatcher 承担 PublishSubject，实现统一的消息推送。 最后，天下无完美架构，唯有高频痛点熟稔于心，不断死磕精进，集思广益，迭代特定场景最优解。 相关资料Canvas，View，Drawable，排版模板：《过目难忘 Android GUI 关系梳理》 DataBinding，Null 安全一致，ViewBinding：《从被误解到 “真香” Jetpack DataBinding》 Dispatcher，消息分发，State，Event：《Jetpack MVVM 分层设计解析》 架构组件解决一致性问题：《耳目一新 Jetpack MVVM 精讲》 Compose，纯函数原子特性，Null 安全一致：《一通百通 “声明式 UI” 扫盲干货》 版权声明 Copyright © 2019-present KunMinX 原创版权所有。 如需 转载本文，或引用、借鉴 本文 “引言、思路、结论、配图” 进行二次创作发行，须注明链接出处，否则我们保留追责权利。","link":"/2022/09/20/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%20Android%20%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%8F%91%E5%B1%95%E5%8F%B2/"},{"title":"","text":"工作多年，进阶 “细节定制”，难免高频接触 “自定义 View”、“GUI 性能优化” 等概念， 诸如 Canvas、Paint、Path；View、Drawable；Layout、Inflater；include、merge、ViewStub；PhoneWindow、ViewRootImpl … 关于 View 体系，开发者 普遍缺乏 “从 0 到 1 完整踩坑” 经历，且多数网文假设读者已有 前置知识 铺垫在先，因而 直奔 “What、How” 细枝末节，对 “Why” 绝口不提， 这使文章读起来 “没头没尾”，让人知难而退。 故这期我们继续 “追根溯源”，铺垫 Android GUI 系统的来龙去脉，相信阅读后，你会对 “为何要学这些技术点、每个技术的「作用边界」到底从哪到哪、技术之间的「关系和顺序」又该如何串起来” 形成清晰理解。 注：本文节选自《重学安卓：过目难忘 Android GUI 关系梳理》，本文可免费阅读和全文转载，转载时须注明本文链接出处。 文章目录一览 前言 拆解思路 Canvas 是排版的根基 View 和 Drawable 是排版的模板 Layout 和 Inflater 不过是后来者 include，merge，ViewStub 是解药的解药 作为承上启下的小结 上文 “Window” 为何一直加个双引号 ViewRootImpl 是怎么帮 Canvas 与窗口对应上的 对症下药 “排版渲染” 性能优化指南 PhoneWindow 本质 及 事件分发内幕 综上 Canvas 是排版的根基所谓排版，即是将一个个图形化内容，以符合预期的方式组合排列，包括并列展示和层叠展示，供用户更好的浏览， 根据《重学安卓：Activity 快乐你不懂》一文的推理，在从零开始缔造的原始操作系统中，UI 排版的工作最初是由 Window 承担，Window 不堪重负，于是责任下发到 View，通过 View/ViewGroup 在 View 树中的递归，以便更快更好完成， 那么是否意味着 View 即是排版的根基？答案是否定的， 因为 View 只是起到 “承载内容、且限制内容展示范围” 的作用，例如做过 “添加水印” 的小伙伴应该都接触过 “贴图控件”，该控件的原理是，在同一个自定义 View 中绘制多个贴图元素，那么显而易见 View 并不是排版的最小单位，被绘制的元素才是， 故而背后的画师 Canvas，才是排版的根基： 排版依赖于绘制 —— 在排版这件事上，Canvas 可以没有 View，但 View 不能没有 Canvas。 Paint 和 Path 都是 Canvas 的助手，与 “排版输出” 存在直接关系的 “最源头 API”，即是 Canvas 本尊。 View 和 Drawable 是排版的模板既然是 View 系统，那就不能只是原始、无序的 “绘制” 本身。 因而在有了 “Window” 和 Canvas 基础上，还需确立 View / ViewGroup 这样规则的 排版标准，从而我们得以基于这套 “标准” 构建 具体可复用模板。 例如 Button、TextView、ImageView 都是 “可复用模板”，开发者日常只需与上层这些 View 打交道、无需接触底层 Canvas，无需做什么都得先手动基于 Canvas 写个数百行排版代码。 且，如对 “现成模板” 不满意，也可自行封装新模板，也即人们所说 “自定义控件”。 与此同时，View 只是模板，如需更改可视化细节，岂不是又要接触 Canvas， 因此，同出于 灵活性和复用 考虑，衍生出 Drawable 模板设计，它的存在是用于负责更具体可视化细节： 例如通过 ShapeDrawable 来描述 View 轮廓和背景、通过 StateListDrawable 来描述 View 点击效果 等等， 使得多数情况下，我们都能直接使用 “Drawable 模板” 描述排版细节，避免良莠不齐开发者 “直接与 Canvas 打交道导致不可预知隐患”。 划重点 👆 👆 👆 16、20、32dp 圆角 16、20dp 圆角 16dp 圆角 图片截自 “小米天气” 客户端：无处不在、各种规格圆角。 Layout 和 Inflater 不过是后来者所以 Layout 和 LayoutInflater 是在有 View 和 Drawable 基础上，才有的后来者。 iOS 开发者常抱怨，在 iOS 上写布局，无预览，全靠想象， 为此，Google 模仿微软 WPF 设计，通过 XML 方式实现 一目了然 “声明式编程”，可实时预览 Layout、shape、selector 乃至极大方便 Android 开发者创建和修改可视化内容。 注：Layout 对应 View 树；shape、selector 对应 Drawable。 然而，XML 声明式编程 解决上述问题的同时，引入新问题： 1.XML 排版资源复用率极低。例如，为不同场景 Button 改圆角样式，无法像动态代码那样，直接代码中定义参数。哪怕不同样式间仅是 “圆角 dp” 存在细微差异，也得重建一个新 shape Drawable XML 描述文件。 2.XML 解析由 LayoutInflater 负责，LayoutInflater 通过 深度优先遍历 算法解析 XML 构建 View 树，从而当 “布局嵌套层次加深” 等原因导致 View 个数过多时，XML 解析会愈加耗时。 include，merge，ViewStub 是解药的解药所以 XML 布局 其实只是一种 充分非必要 构建 View 树方式。 我们看到许多 “东拼西凑” 性能优化网文，不分场合兜售 include，merge，ViewStub，事实上它们仅用于 XML 布局情况 —— 通过减少层级解决 inflate 耗时问题。 像 Telegram 源码 中，这种 “全动态编码” 布局构建方式，就完全用不上从 LayoutInflater 到 ViewStub 技术点。 划重点 👆 👆 👆 作为承上启下的小结综上可见，无论 Button、TextView、ImageView，还是 MaterialButton、TextInputLayout 等，无论其表面如何千变万化，都不过是 为在特定场景下 “符合用户直觉” 而衍生出的排版模板，本质上都是 基于 Canvas 去绘制 “特定样式” 可视化内容。 而 Inflate 也不过是发生在当开发者选择通过 “声明式编程” 而非 “动态编码” 方式去构建 View 树。所以若非使用 LayoutInflater，开发者甚至无须知道 include，merge，ViewStub 的存在。 至此，”Window” &amp; Canvas；View &amp; Drawable；Layout &amp; Inflater；merge &amp; ViewStub，来龙去脉一目了然。 试读内容完。 相关资料重学安卓：过目难忘 Android GUI 关系梳理 版权声明 Copyright © 2019-present KunMinX 原创版权所有。 如需 转载本文，或引用、借鉴 本文 “引言、思路、结论、配图” 进行二次创作发行，须注明链接出处，否则我们保留追责权利。","link":"/2020/01/29/View%20%E7%9A%84%E5%AD%98%E5%9C%A8%E6%84%8F%E4%B9%89/"},{"title":"","text":"Canvas 总共生两胎，一胎 View 体系，二胎 Compose 体系， 上一期《过目难忘 Android GUI 关系梳理》，我们循序渐进拆解了 “View 体系” 各工具的 存在意义 及 相互间关系，鉴于 Compose 离 “普及” 还有很长距离，这一期我们先来介绍 Compose 框架背后的本质。 注：本文节选自《重学安卓：一通百通 “声明式 UI” 扫盲干货》，本文可免费阅读和全文转载，转载时须注明本文链接出处。 声明式 UI 由来事实上，React、Flutter、SwiftUI、Jetpack Compose，这些 UI 框架有个共同鼻祖，即一个名为 elm（不是 “饿了么”）的 UI 框架，是它最早确立并推行 “声明式 UI” 设计理念。 注：“声明式 UI” 这个名称，最初谁定义，暂未找到来源，目前各大官网都称其为 “声明式 UI”，基于我个人理解，其更精确表达是，“响应式 UI 框架的声明式编程分支”，当然，最终我们还是简称为 “声明式 UI”。 —— 那么 “声明式 UI” 到底长啥样？为何要用 “声明式 UI”？相比传统 View 有何优势？本质、存在意义又是什么？ —— React、Flutter、SwiftUI、Jetpack Compose，形态各异，如何透过表象看穿流程机制，从而自行领悟代码 该怎么写、往哪写、怎么改？ 所以今天我们就来统一解析 “声明式 UI” 背后本质，相信阅读后能让你醍醐灌顶。 文章目录一览 前言 声明式 UI 由来 声明式 UI 本质是 “函数式 + 函数式编程” “纯函数” 是 “函数式编程” 基石 “函数式编程” 引入前的混沌世界 “函数式编程” 为何能 “彻底” 解决这类问题？ 引入 “函数式编程” 后的世界 所以为什么会有 “声明式 UI 框架”？ 声明式 UI 运作流程是怎样 声明式 UI 难以替代的好处 函数式编程局限 Note 2020.07.27 加餐： 现有条件下 “View 实例 Null 安全一致性问题” 最优解 1.Java + DataBinding 严格模式 2.Kotlin + ViewBinding 3.Kotlin DSL 动态布局 Note 2022.06.06 加餐 Note 2020.07.31 加餐： 通过 “函数式编程思想” 秒懂 “声明式 UI” 打开方式 综上 声明式 UI 本质是 “函数式 + 响应式编程”声明式 UI、Java8 Stream、RxJava 等，本质上皆是函数式编程 + 响应式编程。 许多文章，从 RxJava 时代起，就照搬官网说法，说 RxJava 是一种 “响应式编程” 框架。 事实上，“响应式编程” 是从 “整体流程数据走向” 的角度来看 —— “输入数据，响应结果”，单凭 “响应式编程” 无益于更好理解 “声明式 UI” 和其他 UI 框架的本质区别， 所以，我们不妨重点关注另一个核心本质 —— 函数式编程。 “纯函数” 是 “函数式编程” 基石老规矩，先讲结论： 声明式 UI 的内部实现是基于函数式编程，且函数式编程基石是纯函数， 函数式编程的存在，主要是通过 “流程的原子化” 实现 “结果的一致性”， 声明式 UI 框架可将多种一致性问题简化为只关注 “数据的一致性问题”， 上述三点，如暂无体会，那接下来，请跟随我脚步铺垫 “声明式 UI” 来龙去脉。 “函数式编程” 引入前的混沌世界以下是常见用法： 通过 findViewById 拿到 TextView 实例，使其作为 Activity 内部共享成员变量，为多个方法所调用，来改变 TextView 状态。 这造成什么问题？ 一旦 TextView 成为 Activity 类的成员变量，分散到各方法中，后续便不可控，因为执行方法 B 时，方法 A 无法知道 方法 B 中对成员变量做了什么，却无差别承受 “成员变量被修改” 所带来影响， 例如当 方法 B 将 TextView 置空，那么 方法 A 调用 TextView 实例时 将面临 Null 安全问题。 可能有人会问，这种问题通过 “手动判空” 不就可以？ 事实上，在软件工程背景下，任何微小隐患都可能被 “指数级” 放大。 一个 App 页面可能有数十个，每个页面控件也可能多达十数个，而每个控件都可能分散在多个方法中，这种情况下，一味寄希望于 “手动判空”，是成本极高且存在 一致性风险 —— 总会有疏忽时候，总会有 “方法 A 记得判空，而方法 B 忘记”。 “函数式编程” 为何能 “彻底” 解决这类问题？因为函数式编程基于纯函数。 什么是纯函数？为何纯函数最终能解决该问题？ 简单来说，纯函数相比普通函数特征是： 只有一个入口 &amp; 只有一个出口。 也即 函数只从 参数列表 这唯一入口 接收外来初值， 并且只从 返回值 这唯一出口 返回结果数据。 除此之外： 不在函数内部执行与运算本身无关其他操作， 不在函数内部调用外部变量、不修改从外部传入的变量， 抛开上述 TextView 的案例，我们先来举个例子看看纯函数本身： 如此一来，在调用该函数时，关注点就只有 “入口和出口” 这两处，不至于蔓延到整个程序，从而 “不可预期情况” 发生概率从 99.9% 骤减为 0 —— 调用者无须了解细节即可放心调用。 引入 “函数式编程” 后的世界函数式编程，除了单个纯函数，也可是多个纯函数链式编程， 即，上一个函数输出 作为下一个函数输入， 整个链同样只有 “开头入参” 这一入口，和 “末尾回调” 这一出口， 至此，我们得以顿悟：为何 RxJava 或 Java8 Stream 是这样写、为何会与常规 “侵入式” 思维发生 “别扭” … 是的，正由于人们习惯了 “自由散漫” 的命令式编程，从未意识到还有 “集中管理” 式，乃至遇到 RxJava 链式编程第一感觉即是，“自由散漫” 在此行不通了， 而这恰恰也是 “函数式编程” 存在意义：通过将过程原子化，来实现结果的一致性 —— 有怎样输入，就有且只有怎样输出，关注点只有这两处，因 “集中管理” 而从根本上杜绝不可预期结果。 划重点 👆 👆 👆 所谓原子化即 “像原子一样不可再分、内部结构稳定、不受外力影响发生改变”。这和 “一致性” 都是大学《软件工程》课提到的概念，读书时不理解没关系，工作多年后还不理解就不对了。 所以为何会有 “声明式 UI 框架”？ 将 UI 系统设计为 “函数式”，反映源码设计者对 彻底解决软工安全问题 不懈追求。 正是由于这锐意进取 “死磕精神”，使软件开发得以不断优化和改进。 通过 “混沌世界” 一节分析，我们已确知，在 “自由散漫” 环境下，实例分散可使不可预期风险被大幅扩散， 加上 《从被误解到 “真香” Jetpack DataBinding》“横竖屏布局控件存在差异” 这一经典案例，如采用 “自由散漫” 方式，同会埋下视图实例 Null 安全一致性问题， 而如今，函数式、响应式，意味着多种一致性问题被简化为 “数据的一致性” 这一种，开发者只需确保数据的来源是唯一且可靠的，即可通过这唯一来源的数据去驱动声明式 UI，从而得到始终一致、符合预期的结果。 声明式 UI 运作流程是怎样试读内容完。 相关资料《重学安卓：一通百通 “声明式 UI” 扫盲干货》 版权声明 Copyright © 2019-present KunMinX 原创版权所有。 如需 转载本文，或引用、借鉴 本文 “引言、思路、结论、配图” 进行二次创作发行，须注明链接出处，否则我们保留追责权利。","link":"/2020/03/06/%E5%A3%B0%E6%98%8E%E5%BC%8F%20UI%20%E8%A7%A3%E6%9E%90/"},{"title":"","text":"关于知识深度和广度，一直众口不一， 例如总有这样的声音，认为客户端 App 开发就是没深度，Framework 开发就是有深度；关注业务逻辑就是没深度，琢磨底层原理才是有深度 … 广度没懂造成这些观点的依据是什么， 笔者认为，应用层和框架层，只是分属两个不同的领域，都是由各个知识点拼接而成，彼此之间并无谁深谁浅之分， 如果开发者学习了应用层，又学习了框架层，本质上只是拓宽了广度，从研究 “茴” 有几种写法，到研究 “龍” 有几种写法；从研究 kotlin 语法有哪些，到研究 C++ 服务有哪些而已， 深度易得学习和接受某领域知识，只是单纯的成长、增长见识和经验，但谈不上思想更深邃， 那么造成 “深度、广度” 区别的关键在于什么， 笔者认为，基于 “第一性原理” 进行推理的思考过程，才有机会构成 “深度理解”，这是一个 “逆向推理 + 正向推理” 的过程，通过不断反思： “该事物的存在缘由是什么，当初是为解决何种场景下的何种需求，问世的该事物。如今时过境迁，该场景该需求是否还在，新场景新需求又如何。在新场景新需求情况下，有无低成本的更优解” 来达成对事物本质的理解、解决方案的举一反三，以及独具一格的颠覆式创新， 也即，从学习 “龍” 的几种写法，到发明 “龙” 的新写法；从学习 Unix 的使用，到另起炉灶手写一个 Linux 内核；从学习传统火箭的发射方式，到离经叛道 “可回收式火箭” —— 唯追根溯源，抓住本质，方才有机会根据 “新的场景” 推陈出新， 做到这份上，才算有深度、是真的真的理解，否则充其量只是新手，浮于表面，略知一二， 综上物质世界过于纷繁，我们不可能也没必要事事都做到 “有深度”， 大部分情况下，光是学习和成长，就已经能过上相对不错的生活， 如对某领域有兴趣、有追求，不妨根据上述思考方式，追根溯源，假以时日，必能在某领域有所建树。 版权声明 Copyright © 2019-present KunMinX 原创版权所有。 如需 转载本文，或引用、借鉴 本文 “引言、思路、结论、配图” 进行二次创作发行，须注明链接出处，否则我们保留追责权利。","link":"/2021/02/05/%E5%85%B3%E4%BA%8E%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86/"},{"title":"协程，协程","text":"水一篇，不保证能看懂，能看懂都是缘分， 关于并发，涉及的关键概念即 “阻塞、多线程、异步、非阻塞、挂起、系统内核、分时复用”， 阻塞如果只有单线程，那么代码执行到 IO 时，会干等着，直到 IO 结束，才再继续下一步，这种 “干等着” 的现象即阻塞， 如果该线程主要用于 “客户端图形渲染” 或 “服务端接收请求响应”，在该线程中阻塞显然不合适，图形渲染和请求响应会被搁置，乃至给人 “无法响应” 的糟糕体验感受， 多线程为此引入多线程技术，在需要 IO 时，新开一个工作线程，并在工作线程中阻塞，如此根据 “分时复用”，主线程的任务很快便能再度被分到 “时间片” 运行，乃至不再卡住， 操作系统与分时复用分时复用是系统内核关于 CPU 资源分配的机制， 操作系统的存在，是为了将有限硬件资源 “合理分配” 以实现效益最大化， 分时复用即是将 CPU 算力以时间为单位进行划分，然后线程之间轮流享用时间片进行计算， 假设 CPU 每秒运行一亿次，此时若有两个线程，则线程 A 分到 1 毫秒，足够 10 万次计算，然后轮到线程 B 分到 1 毫秒运行，再然后线程 A，线程 B … 如此往复，直到任务结束， 连贯性分时复用实现了资源的公平分配，让任务耗时均摊，并且线程执行到阻塞操作时，控制权移交给系统，该线程被系统控制，不再争抢时间片，进一步减少 CPU 资源的浪费， 不过开工作线程再回调，破坏了代码顺序书写的连贯性，甚至可能出现层层嵌套的回调地狱， 为此引入 “非阻塞” 设计， 非阻塞所谓非阻塞即，执行到 “原本意味着阻塞的操作，比如 IO 操作” 时，可以立即返回，继续执行当前线程中原有任务（比如 eventLoop 乃至消息队列中的其他任务），直到 IO 操作结束，系统会发消息到消息队列，稍后线程执行到该消息，读到结果并执行与此相关的下一步， 也即对于 “非阻塞” 操作，可以直接在主线程中执行，执行时不会将主线程阻塞，而是当即返回和继续下一步，直到操作结束时自动返回结果，并根据结果继续相关下一步， 其中 “直到操作结束时自动返回结果，并根据结果继续相关下一步” 又被称作 “异步”，也即上述举例是一种异步非阻塞， 常见非阻塞js 是一种单线程语言，为了能在主线程中执行 IO，js 引入非阻塞机制， 遇到 IO 操作时，交给系统内核，这期间 js 不会干等，仍旧基于 eventLoop 处理图形渲染或请求响应，然后内核会在结束时，发消息到事件循环模型的队列，通过回调函数告知程序可以继续下一步， kotlin 是一种多线程语言，与 java 的区别在于，kotlin 可以通过协程来实现 “非阻塞” 式写法，也即直接在主线程中开一个协程，并在协程中同步方式书写异步代码， 如此，当程序执行到异步块时，会直接挂起整个协程，不阻塞主线程，并且随即切换到子线程，执行阻塞操作，直到操作完，唤醒协程并提供异步任务的结果，来继续协程中的下一步， 也即 kotlin 协程虽然涉及线程切换，但理念上仍然遵照 “异步非阻塞”， 由于 kotlin 编译过程中会转换为 java 字节码，而 java 本身没有采取类似 js 的非阻塞机制，故此可认为，kotlin 是单纯语法层面上实现的异步非阻塞，通过一系列 “编译时自动生成代码” 实现 “同步方式写异步代码”， 多线程的非阻塞js 由于单线程，对于 “计算密集型任务”，仍然只能同步执行，越往后的请求，用户等待响应的时间便越久， 所以尽管 google v8 引擎加持的 nodejs 通过生成机器码能使 js 性能发生质的飞跃，使之适合承担 “IO 密集型” 的 web 服务，如数据库读写、日志记录等，但 js 仍不适合计算密集型业务，例如加解密、甚至 AI 计算， 那么此时需要多线程的非阻塞， 也即对于 IO 密集型或计算密集型任务，都丢给线程池去管理和操作， 对于 IO 型线程池，由于阻塞不怎么占时间片，应尽可能多开和确保每个 IO 请求都被及时处理，那么可根据任务数动态创建和销毁线程，减少系统开销；计算型任务由于吃时间片，应尽可能减少时间上的损耗，那么计算型线程池通常线程数固定，避免创建销毁线程带来的时间开销，且确保每个线程分到的时间片最大化，尽快完成计算任务， 对此还是可以借助 kotlin 协程，通过设置合适的 Dispatcher，余下的协程自己会组织线程池完成任务调度，无需开发者操心细节， 协程故此，java 相较于 js，支持计算密集型任务， kotlin 相较于 java，支持同步方式写异步代码，并且设置 Dispatcher 即可安排合适的任务模式， 由于 kotlin 协程是语法层面实现的异步非阻塞，故此在执行 IO 密集型任务时，由于线程动态创建和频繁切换的缘故，效率可能反而没有单线程的 js 来的高， 综上协程非常适合客户端和服务端开发， 对于 IO 密集型，协程能确保非阻塞；对于计算密集型，协程能减少上下文切换的损耗， 现代化语言基本都有协程，例如 kotlin、swift 都有 async/await 挂起函数。 值得注意的是，js 中也存在 async/await，不过那本质上不具备挂起和恢复能力，不属于协程。 版权声明 Copyright © 2019-present KunMinX 原创版权所有。 如需 转载本文，或引用、借鉴 本文 “引言、思路、结论、配图” 进行二次创作发行，须注明链接出处，否则我们保留追责权利。","link":"/2023/05/20/%E5%8D%8F%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B/"},{"title":"Kotlin 感觉","text":"给我感觉，这是一门最小完备的语言，功能实用，无以复减， 语法上主要印象有 6 方面， 声明方式和字面量的简化1.使用 val、var 来动态声明，编译时则会编译成静态类型， 2.数字字面量可以写成 val num = 1_000_000.99_99 方便人类查阅， 字符串字面量可以写成 1234567val num = 1_000_000.99_99val s = &quot;&quot;&quot; this is a xxxx, so that this is a xx, so that this is not a xx, so the number is $num&quot;&quot;&quot; 无需 + 拼接，无需 \\n 换行， 控制流与中缀表达式1.控制流可以直接作为表达式来返回结果，例如 123fun test(): String { return if(xxx) &quot;a&quot; else &quot;b&quot;} 2.函数也可直接以表达式方式书写，例如 1fun test() = if(xxx) &quot;a&quot; else &quot;b&quot; 3.区间可以更直观简便，例如循环的步进可以这样写 12for(i in 0..10) { ... }for(i in 0..&lt;10) { ... } 4.in、 ..、 ..&lt;，都是中缀表达式，开发者也可通过 infix 修饰的函数自定义中缀， 123456infix fun Any.to(other: Any) { ... }fun test() { print(1 to &quot;s&quot;) //等同于 print(1.to(&quot;s&quot;))} 头等公民及其延伸kotlin 允许函数和变量可以不是类成员，直接定义在文件中，作为顶层函数/变量供全局访问， 如此一来，蝴蝶效应，引发诸多连锁改善， 1.由于函数可以不是类成员，kotlin 的语法索性统一为，不得在参数中为类成员赋值，如此便为赋值运算符用作 “参数默认值” 预留了空间， 反观 java，由于方法总是类成员，延伸出可在方法实参中为类成员赋值的写法，而这种鸡肋用法对后来 “参数默认值” 语法的出现造成阻碍， 123456789//javavoid setAdapter(Adapter adpt){ ... }Adapter adpt;setAdapter(adpt = new Adapter());//kotlinfun setAdapter(count: Int, adpt: Adapter = Adapter()){ ... }setAdapter() //参数都沿用默认值setAdapter(adpt = MyAdapter()) //指定某参数使用自定义值 2.由于函数和变量可以和类一样直接在文件中声明（作为 “头等公民”），故此延伸出拓展、闭包、内联、委托等， 这拓展即是以顶层函数/变量的形式，对类成员进行拓展。在拓展函数中，可以像在类中一样，通过 this 访问到当前类对象， 123fun String.haha(s: String){ this.add(s)} 这闭包（也即 lambda，个人习惯称之为闭包），可直接用在函数参数中，实现回调， 并且如果闭包是函数唯一的参数，那么调用该函数时，可以省略 ( )，直接写闭包 { }， 123456789fun doSomething(action: (String)-&gt;Unit) { action(&quot;haha&quot;)}fun test(){ doSomething { print(it) }} 3.由于闭包在编译时是生成一个匿名对象，如果闭包被用在循环中，会不断生成匿名对象，影响性能，故此参数有闭包的函数，一般会通过 inline 内联来修饰， 如此编译时，不会为闭包生成匿名对象和方法来与目标连接，而是直接将闭包中的内容粘贴到目标位置，即便是循环，性能也和代码是直接写在循环中并无二致， 123inline fun doSomething(action: (String)-&gt;Unit) { action(&quot;haha&quot;)} 4.既然有拓展，那么除了拓展函数，也可定义拓展属性， 拓展属性除了简化 getter setter 的调用，某种程度上也简化了委托，也即可在 getter setter 中植入想要的委托代码，如此在访问该属性时，能顺带执行这些代码， 123456789var TextView.text: CharSequence get() = { print(&quot;get $getText()&quot;) return getText() } set(value) { setText(value) print(&quot;set $value&quot;) } 5.那么拓展、闭包、内联一组合，便能形成一些实用的 “作用域函数”，例如 apply 函数， 可见不仅是 T.apply 用到拓展，T.( ) 也用到，这使目标对象例如 Paint( ) 在使用 apply 函数时，得以在闭包 { } 中通过隐式 this 来访问 paint 的属性，例如 color、style 等， 1234567891011inline fun &lt;T&gt; T.apply(action: T.()-&gt;Unit): T { action() return this}fun test(){ val paint = Paint().apply { color = &quot;#aaaaaaa&quot; style = Stroke }} 空安全与可空类型1.kotlin 通过 ? 操作符彻底解决 java 的 null 安全问题（以下简称 NPE），开发者无需再写 if ( null != x )，也无需使用特定框架来规避特定领域的 NPE， 2.例如从前在 java 下通过 DataBinding ObservableField 的间接通知来规避 “横竖屏布局的 View NPE”，而这涉及 BindingAdapter、xml 属性绑定等一系列前置工作， 如今 kotlin 下可以直接通过使用 ViewBinding，书写便捷，性能还更高些， 1binding?.tv.setText(xxx) 3.除了 ?. 跳过空对象调用，还有 ?: 操作符来提供非空默认值， 例如 val b = a ?: “xxx”，如 a 为 null，则表达式返回 ?: 后面值， 4.对应的，kotlin 下类型分为 “可空” 和 “不可空” 两种，可空类型都是 Any? 子类，不可空类型都是 Any 子类。多数情况下会是创建可空类型，然后使用 ? 操作符， 协程和异步代码同步写1.在 java 中，若想避免主线程被阻塞，通常会切到一个子线程，让子线程去阻塞， 不过想要再切回来，只能通过回调，如此在某些场景下可能引发多层嵌套（回调地狱）， 并且如果希望多个任务并发（concurrent）或并行（parallel）执行，且执行后在同一时间汇合、继续下一步，java 线程不是那么好操作，需要手动安排亲和度等细节， 故此 kotlin 下可以使用协程， 2.在协程中，原本需要回调的异步方式，可以同步方式书写， 以下我们在主线程中，通过 MainScope.launch 启动一个协程，协程中共包含 4 个步骤，分别是打印开始信息、执行任务 1、任务2、打印结束信息， 按照以往 java 线程的方式，应该会先打印开始信息、结束信息，然后打印任务1、任务2， 而协程不一样，当协程中所有子任务都切到子线程开始运行时，整个协程被挂起，也即打印完开始信息、任务 1 和任务 2 都切到子线程时，整个协程立刻被挂起，避免主线程被阻塞， 期间在子线程中分别打印了任务 1、任务 2， 待到任务 1 任务 2 都完成，这个协程又被恢复，在步骤 4 中，拿着任务 1、任务 2 各自返回的异步结果，来打印结束信息， 整个运行过程就如同书写的那样，符合人类预期， 12345678910111213141516171819202122fun test(){ MainScope().launch { println(&quot;start&quot;) //步骤1 val job1 = async(Dispatcher.Default){ //步骤2 delay(1000) println(&quot;job1 done&quot;) &quot;job1_hhhh&quot; } val job2 = async(Dispatcher.Default){ //步骤3 delay(1000) println(&quot;job1 done&quot;) &quot;job2_hhhh&quot; } printlin(&quot;end ${job1.await()} and ${job2.await()}&quot;) //步骤4 }}//打印结果：//start//job1 done//job2 done//end job1_hhhh and job2_hhhh 3.对于 IO 密集型任务，可在子任务中安排 Dispatcher.IO 调度器，其底层是使用 “动态线程池”，使尽可能多的处理 IO 请求（阻塞的线程不再主动抢时间片，无需担心占用计算型线程的时间片）， 而对于计算密集型任务，可在子任务中安排 Dispatcher.Default 调度器，其底层是使用 “并行线程池”，根据 CPU 核心数，安排固定数目的线程到不同核心，最大限度减少任务完成时间， 响应式流开发模式如果只能用一张图来形容 “对 kotlin 的感觉”，笔者认为 flow 可担此任， 123fun test() = flow { emit(Sealed)}.flowOn(IO) 如上，伪代码中涵盖了 flow、sealed class、协程调度器等元素，示意 “在子线程中处理任务，并在过程中发射 ‘密封类结果’ 到主线程观察者” 的响应式开发模式， 软件形形色色，无非 “数据来，数据去”，语言则是实现这一切的工具， 从这角度来看，响应式开发、单向数据流，浑然天成、理所当然 —— 软件开发本就如此应当， 最后kotlin 是 java IDE 厂商 jetbrain 打磨 12 年之作，通过语法糖实现了诸多 “实用、且原本在 java 中需要手写乃至成本高昂” 的特性，所以 kotlin 可以说是对 java 及其设计模式的最佳实践， 有人说 kotlin 是 java pro max，笔者认为 kotlin 是语法最小完备的现代化语言，功能实用，无以复减， 目前唯一觉得不适的是 jvm 内存占用，在 jetbrain IDE 眼里，内存跟不要钱似的；在苹果眼里，内存比黄金还贵，而运行在 jvm 上的 kotlin，也是 400MB 起步，在 8GB 丐版 mac 下也就能跑 10 来个， 期待 jetbrain 对 kotlin/native 的持续发力，使让 macOS 等桌面操作系统也能用上内存只占 60-70MB 的软件，","link":"/2023/08/03/Kotlin%20%E6%84%9F%E8%A7%89/"}],"tags":[],"categories":[],"pages":[]}