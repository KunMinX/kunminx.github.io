<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KunMinX 博客</title>
  
  <subtitle>公元 3000 年</subtitle>
  <link href="https://www.kunminx.com/atom.xml" rel="self"/>
  
  <link href="https://www.kunminx.com/"/>
  <updated>2023-08-04T05:08:19.753Z</updated>
  <id>https://www.kunminx.com/</id>
  
  <author>
    <name>KunMinX</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin 感觉</title>
    <link href="https://www.kunminx.com/2023/08/03/Kotlin%20%E6%84%9F%E8%A7%89/"/>
    <id>https://www.kunminx.com/2023/08/03/Kotlin%20%E6%84%9F%E8%A7%89/</id>
    <published>2023-08-03T08:00:00.000Z</published>
    <updated>2023-08-04T05:08:19.753Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>给我感觉，这是一门最小完备的语言，功能实用，无以复减，</p><p>语法上主要印象有 6 方面，</p><h3 id="声明方式和字面量的简化"><a href="#声明方式和字面量的简化" class="headerlink" title="声明方式和字面量的简化"></a>声明方式和字面量的简化</h3><p>1.使用 val、var 来动态声明，编译时则会编译成静态类型，</p><p>2.数字字面量可以写成 val num = 1_000_000.99_99 方便人类查阅，</p><p>字符串字面量可以写成 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> num = <span class="hljs-number">1_000_000.99_99</span><br><span class="hljs-keyword">val</span> s = <span class="hljs-string">"""</span><br><span class="hljs-string">this is a xxxx,</span><br><span class="hljs-string">so that this is a xx,</span><br><span class="hljs-string">so that this is not a xx,</span><br><span class="hljs-string">so the number is <span class="hljs-variable">$num</span></span><br><span class="hljs-string">"""</span><br></code></pre></td></tr></table></figure><p>无需 + 拼接，无需 \n 换行，</p><h3 id="控制流与中缀表达式"><a href="#控制流与中缀表达式" class="headerlink" title="控制流与中缀表达式"></a>控制流与中缀表达式</h3><p>1.控制流可以直接作为表达式来返回结果，例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>: String &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span>(xxx) <span class="hljs-string">"a"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"b"</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.函数也可直接以表达式方式书写，例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">if</span>(xxx) <span class="hljs-string">"a"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"b"</span><br></code></pre></td></tr></table></figure><p>3.区间可以更直观简便，例如循环的步进可以这样写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span>) &#123; ... &#125;<br><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>) &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>4.<code>in</code>、 <code>..</code>、 <code>..&lt;</code>，都是中缀表达式，开发者也可通过 infix 修饰的函数自定义中缀，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Any.<span class="hljs-title">to</span><span class="hljs-params">(other: <span class="hljs-type">Any</span>)</span></span> &#123; ... &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>print(<span class="hljs-number">1</span> to <span class="hljs-string">"s"</span>)<br>  <span class="hljs-comment">//等同于 print(1.to("s"))</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="头等公民及其延伸"><a href="#头等公民及其延伸" class="headerlink" title="头等公民及其延伸"></a>头等公民及其延伸</h3><p>kotlin 允许函数和变量可以不是类成员，直接定义在文件中，作为顶层函数/变量供全局访问，</p><p>如此一来，蝴蝶效应，引发诸多连锁改善，</p><p>1.由于函数可以不是类成员，kotlin 的语法索性统一为，不得在参数中为类成员赋值，如此便为赋值运算符用作 “参数默认值” 预留了空间，</p><p>反观 java，由于方法总是类成员，延伸出可在方法实参中为类成员赋值的写法，而这种鸡肋用法对后来 “参数默认值” 语法的出现造成阻碍，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//java</span><br>void setAdapter(Adapter adpt)&#123; ... &#125;<br>Adapter adpt;<br>setAdapter(adpt = new Adapter());<br><br><span class="hljs-comment">//kotlin</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setAdapter</span><span class="hljs-params">(count: <span class="hljs-type">Int</span>, adpt: <span class="hljs-type">Adapter</span> = Adapter()</span></span>)&#123; ... &#125;<br>setAdapter() <span class="hljs-comment">//参数都沿用默认值</span><br>setAdapter(adpt = MyAdapter()) <span class="hljs-comment">//指定某参数使用自定义值</span><br></code></pre></td></tr></table></figure><p>2.由于函数和变量可以和类一样直接在文件中声明（作为 “头等公民”），故此延伸出拓展、闭包、内联、委托等，</p><p>这拓展即是以顶层函数/变量的形式，对类成员进行拓展。在拓展函数中，可以像在类中一样，通过 this 访问到当前类对象，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">haha</span><span class="hljs-params">(s: <span class="hljs-type">String</span>)</span></span>&#123;<br><span class="hljs-keyword">this</span>.add(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>这闭包（也即 lambda，个人习惯称之为闭包），可直接用在函数参数中，实现回调，</p><p>并且如果闭包是函数唯一的参数，那么调用该函数时，可以省略 ( )，直接写闭包 { }，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(action: (<span class="hljs-type">String</span>)-&gt;<span class="hljs-type">Unit</span>)</span></span> &#123;<br>action(<span class="hljs-string">"haha"</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>doSomething &#123;<br>print(it)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.由于闭包在编译时是生成一个匿名对象，如果闭包被用在循环中，会不断生成匿名对象，影响性能，故此参数有闭包的函数，一般会通过 inline 内联来修饰，</p><p>如此编译时，不会为闭包生成匿名对象和方法来与目标连接，而是直接将闭包中的内容粘贴到目标位置，即便是循环，性能也和代码是直接写在循环中并无二致，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(action: (<span class="hljs-type">String</span>)-&gt;<span class="hljs-type">Unit</span>)</span></span> &#123;<br>action(<span class="hljs-string">"haha"</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>4.既然有拓展，那么除了拓展函数，也可定义拓展属性，</p><p>拓展属性除了简化 getter setter 的调用，某种程度上也简化了委托，也即可在 getter setter 中植入想要的委托代码，如此在访问该属性时，能顺带执行这些代码，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> TextView.text: CharSequence<br>  <span class="hljs-keyword">get</span>() = &#123;<br>    print(<span class="hljs-string">"get <span class="hljs-variable">$getText</span>()"</span>)<br>    <span class="hljs-keyword">return</span> getText()<br>  &#125;<br>  <span class="hljs-keyword">set</span>(value) &#123;<br>    setText(value)<br>    print(<span class="hljs-string">"set <span class="hljs-variable">$value</span>"</span>)<br>  &#125;<br></code></pre></td></tr></table></figure><p>5.那么拓展、闭包、内联一组合，便能形成一些实用的 “作用域函数”，例如 apply 函数，</p><p>可见不仅是 T.apply 用到拓展，T.( ) 也用到，这使目标对象例如 Paint( ) 在使用 apply 函数时，得以在闭包 { } 中通过隐式 this 来访问 paint 的属性，例如 color、style 等，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">apply</span><span class="hljs-params">(action: <span class="hljs-type">T</span>.()-&gt;<span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>action()<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">val</span> paint = Paint().apply &#123;<br>    color = <span class="hljs-string">"#aaaaaaa"</span><br>    style = Stroke<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空安全与可空类型"><a href="#空安全与可空类型" class="headerlink" title="空安全与可空类型"></a>空安全与可空类型</h3><p>1.kotlin 通过 ? 操作符彻底解决 java 的 null 安全问题（以下简称 NPE），开发者无需再写 <code>if ( null != x )</code>，也无需使用特定框架来规避特定领域的 NPE，</p><p>2.例如从前在 java 下通过 DataBinding ObservableField 的间接通知来规避 “横竖屏布局的 View NPE”，而这涉及 BindingAdapter、xml 属性绑定等一系列前置工作，</p><p>如今 kotlin 下可以直接通过使用 ViewBinding，书写便捷，性能还更高些，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">binding?.tv.setText(xxx)<br></code></pre></td></tr></table></figure><p>3.除了 <code>?.</code> 跳过空对象调用，还有 <code>?:</code> 操作符来提供非空默认值，</p><p>例如 val b = a <code>?:</code> “xxx”，如 a 为 null，则表达式返回 <code>?:</code> 后面值，</p><p>4.对应的，kotlin 下类型分为 “可空” 和 “不可空” 两种，可空类型都是 Any? 子类，不可空类型都是 Any 子类。多数情况下会是创建可空类型，然后使用 ? 操作符，</p><h3 id="协程和异步代码同步写"><a href="#协程和异步代码同步写" class="headerlink" title="协程和异步代码同步写"></a>协程和异步代码同步写</h3><p>1.在 java 中，若想避免主线程被阻塞，通常会切到一个子线程，让子线程去阻塞，</p><p>不过想要再切回来，只能通过回调，如此在某些场景下可能引发多层嵌套（回调地狱），</p><p>并且如果希望多个任务并发（concurrent）或并行（parallel）执行，且执行后在同一时间汇合、继续下一步，java 线程不是那么好操作，需要手动安排亲和度等细节，</p><p>故此 kotlin 下可以使用协程，</p><p>2.在协程中，原本需要回调的异步方式，可以同步方式书写，</p><p>以下我们在主线程中，通过 MainScope.launch 启动一个协程，协程中共包含 4 个步骤，分别是打印开始信息、执行任务 1、任务2、打印结束信息，</p><p>按照以往 java 线程的方式，应该会先打印开始信息、结束信息，然后打印任务1、任务2，</p><p>而协程不一样，当协程中所有子任务都切到子线程开始运行时，整个协程被挂起，也即打印完开始信息、任务 1 和任务 2 都切到子线程时，整个协程立刻被挂起，避免主线程被阻塞，</p><p>期间在子线程中分别打印了任务 1、任务 2，</p><p>待到任务 1 任务 2 都完成，这个协程又被恢复，在步骤 4 中，拿着任务 1、任务 2 各自返回的异步结果，来打印结束信息，</p><p>整个运行过程就如同书写的那样，符合人类预期，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>MainScope().launch &#123;<br>println(<span class="hljs-string">"start"</span>)   <span class="hljs-comment">//步骤1</span><br><span class="hljs-keyword">val</span> job1 = async(Dispatcher.Default)&#123;  <span class="hljs-comment">//步骤2</span><br>delay(<span class="hljs-number">1000</span>) <br>println(<span class="hljs-string">"job1 done"</span>) <br>      <span class="hljs-string">"job1_hhhh"</span><br>&#125;<br><span class="hljs-keyword">val</span> job2 = async(Dispatcher.Default)&#123;  <span class="hljs-comment">//步骤3</span><br>delay(<span class="hljs-number">1000</span>) <br>println(<span class="hljs-string">"job1 done"</span>) <br>      <span class="hljs-string">"job2_hhhh"</span><br>&#125;<br>printlin(<span class="hljs-string">"end <span class="hljs-subst">$&#123;job1.await()&#125;</span> and <span class="hljs-subst">$&#123;job2.await()&#125;</span>"</span>) <span class="hljs-comment">//步骤4</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果：</span><br><span class="hljs-comment">//start</span><br><span class="hljs-comment">//job1 done</span><br><span class="hljs-comment">//job2 done</span><br><span class="hljs-comment">//end job1_hhhh and job2_hhhh</span><br></code></pre></td></tr></table></figure><p>3.对于 IO 密集型任务，可在子任务中安排 Dispatcher.IO 调度器，其底层是使用 “动态线程池”，使尽可能多的处理 IO 请求（阻塞的线程不再主动抢时间片，无需担心占用计算型线程的时间片），</p><p>而对于计算密集型任务，可在子任务中安排 Dispatcher.Default 调度器，其底层是使用 “并行线程池”，根据 CPU 核心数，安排固定数目的线程到不同核心，最大限度减少任务完成时间，</p><h3 id="响应式流开发模式"><a href="#响应式流开发模式" class="headerlink" title="响应式流开发模式"></a>响应式流开发模式</h3><p>如果只能用一张图来形容 “对 kotlin 的感觉”，笔者认为 flow 可担此任，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> = flow &#123;<br>emit(Sealed)<br>&#125;.flowOn(IO)<br></code></pre></td></tr></table></figure><p>如上，伪代码中涵盖了 flow、sealed class、协程调度器等元素，示意 “在子线程中处理任务，并在过程中发射 ‘密封类结果’ 到主线程观察者” 的响应式开发模式，</p><p>软件形形色色，无非 “数据来，数据去”，语言则是实现这一切的工具，</p><p>从这角度来看，响应式开发、单向数据流，浑然天成、理所当然 —— 软件开发本就如此应当，</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>kotlin 是 java IDE 厂商 jetbrain 打磨 12 年之作，通过语法糖实现了诸多 “实用、且原本在 java 中需要手写乃至成本高昂” 的特性，所以 kotlin 可以说是对 java 及其设计模式的最佳实践，</p><p>有人说 kotlin 是 java pro max，笔者认为 kotlin 是语法最小完备的现代化语言，功能实用，无以复减，</p><p>目前唯一觉得不适的是 jvm 内存占用，在 jetbrain IDE 眼里，内存跟不要钱似的；在苹果眼里，内存比黄金还贵，而运行在 jvm 上的 kotlin，也是 400MB 起步，在 8GB 丐版 mac 下也就能跑 10 来个，</p><p>期待 jetbrain 对 kotlin/native 的持续发力，使让 macOS 等桌面操作系统也能用上内存只占 60-70MB 的软件，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;p&gt;给我感觉，这是一门最小完备的语言，功能实用，无以复减，&lt;/p&gt;
&lt;p&gt;语法上主要印象有 6 方面，&lt;/p&gt;
&lt;h3 id=&quot;声明方式和字面量的简化&quot;&gt;&lt;a href=&quot;#声明方式和字面量的简化&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>协程，协程</title>
    <link href="https://www.kunminx.com/2023/05/20/%E5%8D%8F%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B/"/>
    <id>https://www.kunminx.com/2023/05/20/%E5%8D%8F%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B/</id>
    <published>2023-05-20T06:00:00.000Z</published>
    <updated>2023-07-31T02:19:22.442Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>水一篇，不保证能看懂，能看懂都是缘分，</p><p>关于并发，涉及的关键概念即 “阻塞、多线程、异步、非阻塞、挂起、系统内核、分时复用”，</p><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>如果只有单线程，那么代码执行到 IO 时，会干等着，直到 IO 结束，才再继续下一步，这种 “干等着” 的现象即阻塞，</p><p>如果该线程主要用于 “客户端图形渲染” 或 “服务端接收请求响应”，在该线程中阻塞显然不合适，图形渲染和请求响应会被搁置，乃至给人 “无法响应” 的糟糕体验感受，</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>为此引入多线程技术，在需要 IO 时，新开一个工作线程，并在工作线程中阻塞，如此根据 “分时复用”，主线程的任务很快便能再度被分到 “时间片” 运行，乃至不再卡住，</p><h2 id="操作系统与分时复用"><a href="#操作系统与分时复用" class="headerlink" title="操作系统与分时复用"></a>操作系统与分时复用</h2><p>分时复用是系统内核关于 CPU 资源分配的机制，</p><p>操作系统的存在，是为了将有限硬件资源 “合理分配” 以实现效益最大化，</p><p>分时复用即是将 CPU 算力以时间为单位进行划分，然后线程之间轮流享用时间片进行计算，</p><p>假设 CPU 每秒运行一亿次，此时若有两个线程，则线程 A 分到 1 毫秒，足够 10 万次计算，然后轮到线程 B 分到 1 毫秒运行，再然后线程 A，线程 B … 如此往复，直到任务结束，</p><h2 id="连贯性"><a href="#连贯性" class="headerlink" title="连贯性"></a>连贯性</h2><p>分时复用实现了资源的公平分配，让任务耗时均摊，并且线程执行到阻塞操作时，控制权移交给系统，该线程被系统控制，不再争抢时间片，进一步减少 CPU 资源的浪费，</p><p>不过开工作线程再回调，破坏了代码顺序书写的连贯性，甚至可能出现层层嵌套的回调地狱，</p><p>为此引入 “非阻塞” 设计，</p><h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><p>所谓非阻塞即，执行到 “原本意味着阻塞的操作，比如 IO 操作” 时，可以立即返回，继续执行当前线程中原有任务（比如 eventLoop 乃至消息队列中的其他任务），直到 IO 操作结束，系统会发消息到消息队列，稍后线程执行到该消息，读到结果并执行与此相关的下一步，</p><p>也即对于 “非阻塞” 操作，可以直接在主线程中执行，执行时不会将主线程阻塞，而是当即返回和继续下一步，直到操作结束时自动返回结果，并根据结果继续相关下一步，</p><p>其中 “直到操作结束时自动返回结果，并根据结果继续相关下一步” 又被称作 “异步”，也即上述举例是一种异步非阻塞，</p><h2 id="常见非阻塞"><a href="#常见非阻塞" class="headerlink" title="常见非阻塞"></a>常见非阻塞</h2><p>js 是一种单线程语言，为了能在主线程中执行 IO，js 引入非阻塞机制，</p><p>遇到 IO 操作时，交给系统内核，这期间 js 不会干等，仍旧基于 eventLoop 处理图形渲染或请求响应，然后内核会在结束时，发消息到事件循环模型的队列，通过回调函数告知程序可以继续下一步，</p><p>kotlin 是一种多线程语言，与 java 的区别在于，kotlin 可以通过协程来实现 “非阻塞” 式写法，也即直接在主线程中开一个协程，并在协程中同步方式书写异步代码，</p><p>如此，当程序执行到异步块时，会直接挂起整个协程，不阻塞主线程，并且随即切换到子线程，执行阻塞操作，直到操作完，唤醒协程并提供异步任务的结果，来继续协程中的下一步，</p><p>也即 kotlin 协程虽然涉及线程切换，但理念上仍然遵照 “异步非阻塞”，</p><p>由于 kotlin 编译过程中会转换为 java 字节码，而 java 本身没有采取类似 js 的非阻塞机制，故此可认为，kotlin 是单纯语法层面上实现的异步非阻塞，通过一系列 “编译时自动生成代码” 实现 “同步方式写异步代码”，</p><h2 id="多线程的非阻塞"><a href="#多线程的非阻塞" class="headerlink" title="多线程的非阻塞"></a>多线程的非阻塞</h2><p>js 由于单线程，对于 “计算密集型任务”，仍然只能同步执行，越往后的请求，用户等待响应的时间便越久，</p><p>所以尽管 google v8 引擎加持的 nodejs 通过生成机器码能使 js 性能发生质的飞跃，使之适合承担 “IO 密集型” 的 web 服务，如数据库读写、日志记录等，但 js 仍不适合计算密集型业务，例如加解密、甚至 AI 计算，</p><p>那么此时需要多线程的非阻塞，</p><p>也即对于 IO 密集型或计算密集型任务，都丢给线程池去管理和操作，</p><p>对于 IO 型线程池，由于阻塞不怎么占时间片，应尽可能多开和确保每个 IO 请求都被及时处理，那么可根据任务数动态创建和销毁线程，减少系统开销；计算型任务由于吃时间片，应尽可能减少时间上的损耗，那么计算型线程池通常线程数固定，避免创建销毁线程带来的时间开销，且确保每个线程分到的时间片最大化，尽快完成计算任务，</p><p>对此还是可以借助 kotlin 协程，通过设置合适的 Dispatcher，余下的协程自己会组织线程池完成任务调度，无需开发者操心细节，</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>故此，java 相较于 js，支持计算密集型任务，</p><p>kotlin 相较于 java，支持同步方式写异步代码，并且设置 Dispatcher 即可安排合适的任务模式，</p><p>由于 kotlin 协程是语法层面实现的异步非阻塞，故此在执行 IO 密集型任务时，由于线程动态创建和频繁切换的缘故，效率可能反而没有单线程的 js 来的高，</p><h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p>协程非常适合客户端和服务端开发，</p><p>对于 IO 密集型，协程能确保非阻塞；对于计算密集型，协程能减少上下文切换的损耗，</p><p>现代化语言基本都有协程，例如 kotlin、swift 都有 async/await 挂起函数。</p><p>值得注意的是，js 中也存在 async/await，不过那本质上不具备挂起和恢复能力，不属于协程。</p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><blockquote><p>Copyright © 2019-present KunMinX 原创版权所有。</p></blockquote><p>如需 <strong>转载本文，或引用、借鉴</strong> 本文 “引言、思路、结论、配图” 进行二次创作发行，<strong>须注明链接出处</strong>，否则我们保留追责权利。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;p&gt;水一篇，不保证能看懂，能看懂都是缘分，&lt;/p&gt;
&lt;p&gt;关于并发，涉及的关键概念即 “阻塞、多线程、异步、非阻塞、挂起、系统内核、分时复用”，&lt;/p&gt;
&lt;h2 id=&quot;阻塞&quot;&gt;&lt;a href=&quot;#阻塞&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论提线木偶的自我修养</title>
    <link href="https://www.kunminx.com/2022/12/26/%E8%AE%BA%E6%8F%90%E7%BA%BF%E6%9C%A8%E5%81%B6%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    <id>https://www.kunminx.com/2022/12/26/%E8%AE%BA%E6%8F%90%E7%BA%BF%E6%9C%A8%E5%81%B6%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</id>
    <published>2022-12-26T07:00:00.000Z</published>
    <updated>2023-07-25T06:55:15.990Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>像看待新冠病毒一样，我们逐渐学会长期与 “来自他人的恶意” 共处。</p><p>以下是截至目前，结合多领域视角所构建的理解：</p><h3 id="设定如此，故高频且普遍"><a href="#设定如此，故高频且普遍" class="headerlink" title="设定如此，故高频且普遍"></a>设定如此，故高频且普遍</h3><p>人是生物，生物是基因载体，基因的演化迭代机制，使其默认隐含对优越性的追求，因而人本就有优越感需求，</p><p>超脱优越感毕竟难事，因而定力较弱的一部分人，出于生物节能本能，无一例外摸索出 “最低成本、最短路径” —— 通过 “语言霸凌、网络暴力、逞口舌之快” 等方式秀优越，</p><p>常见套路即，<strong>动辄臆想和放大某杠点</strong>（例如 阴谋、愚蠢、不够、不公），<strong>然后拿着这杠点去抬杠锤人</strong>，期间自动占据了道德制高点、彰显了正义和优越、获得 “来得快” 的情绪爽感/心理收益，</p><blockquote><p>由于 “占理” 和 “道德” 已沦为 “彰显优越感乃至嘴爽” 的工具，因而这里面再没有什么道理和道德，怎么容易怎么来，</p></blockquote><p>你会发现，那些动辄针对某个人及其作品的抬杠，本身多是从臆想出发的无端指责，通过各种言外之意暗讽，通过其个人的偏见以偏概全，这与你亲历的付出、拥护的事实、期待的反馈产生冲突，于是容易构成你的心理不平衡、产生负面情绪困扰、乃至做出不理智回应。</p><h3 id="平等独立，和而不同"><a href="#平等独立，和而不同" class="headerlink" title="平等独立，和而不同"></a>平等独立，和而不同</h3><p>理解了外部因素，再来了解下内部因素。</p><p>之所以在意别人的碎嘴、容易被带节奏的偏见声影响，是因为潜意识深处认定 “真相只能有一个”，乃至潜意识自动推导出 “如果别人是对的，我就一定是错的”、“如果别人有发声，那他说的就是真的” 等荒谬结论，</p><p>而抬杠者为了彰显，恰恰又喜欢 “装模作样 居高临下” 来欺弄人，</p><blockquote><p>为此，只要别人 “偷梁换柱 颠倒是非”，你便容易心理失衡，感到耻辱或危机 —— 就好像，它说什么就是什么，它怎么都有理，然后消耗的全是你，</p></blockquote><p>那么，既然这结构不合理，修正便是 —— “<strong>真相和真理是个多面体，不具唯一性和绝对性</strong>” —— 每个人都只能从某个角度出发看到 “真” 的某个面，无论其 “狐假虎威” 装的有多逼真、观点有多绝对，所陈述的观点依然只代表其个人、顶多是代表其同类，而非全人类，更不至于是客观完整的 “真” 本身，</p><p>由此，不再过度在意有的没的 —— “你可以有你的观点，我不在意你到底什么观点，我也可以有我的观点，我保持我观点的独立，不寻求认同，也不接受征服”，</p><blockquote><p>—— 众生平等，没有利害，没有失衡，没有困扰，没有索求，也没有妥协。</p></blockquote><p>本自具足，而无需彰显。</p><h3 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h3><blockquote><p>Copyright © 2019-present KunMinX 原创版权所有。</p></blockquote><p>如需 <strong>转载本文，或引用、借鉴</strong> 本文 “引言、思路、结论、配图” 进行二次创作发行，<strong>须注明链接出处</strong>，否则我们保留追责权利。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;p&gt;像看待新冠病毒一样，我们逐渐学会长期与 “来自他人的恶意” 共处。&lt;/p&gt;
&lt;p&gt;以下是截至目前，结合多领域视角所构建的理解：&lt;/p&gt;
&lt;h3 id=&quot;设定如此，故高频且普遍&quot;&gt;&lt;a href=&quot;#设定如此，故高频且普遍&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MVI 的存在意义</title>
    <link href="https://www.kunminx.com/2022/09/20/MVI%20%E7%9A%84%E5%AD%98%E5%9C%A8%E6%84%8F%E4%B9%89/"/>
    <id>https://www.kunminx.com/2022/09/20/MVI%20%E7%9A%84%E5%AD%98%E5%9C%A8%E6%84%8F%E4%B9%89/</id>
    <published>2022-09-20T04:00:00.000Z</published>
    <updated>2023-07-25T11:41:24.098Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学技术要学本质。对 MVI 的有效理解，源于对 “响应式编程 作用和漏洞” 等关键细节的挖掘，</p><p>故这期专为 MVI 打磨一篇 “通俗易懂、看完便理解来龙去脉、并能活学活用”，相信阅读后你会耳目一新。</p><h2 id="文章目录一览"><a href="#文章目录一览" class="headerlink" title="文章目录一览"></a>文章目录一览</h2><ul><li><p>前言</p></li><li><p>响应式编程</p><ul><li><p>响应式编程的好处</p></li><li><p>响应式编程的漏洞</p></li><li><p>响应式编程的困境</p></li></ul></li><li><p>MVI 的存在意义</p></li><li><p>MVI 的实现</p><ul><li>函数式编程思想</li><li>MVI 怎样实现纯函数效果</li><li>存在哪些副作用</li><li>整体流程</li></ul></li><li><p>当下开发现状的反思</p><ul><li>从源头把问题消灭</li><li>什么是过度设计，如何避免</li><li>平替方案的探索</li></ul></li><li><p>综上</p></li></ul><h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><p>谈到 MVI，首先要提的是 “响应式编程”，响应式是 Reactive 翻译成中文叫法，对应 Java 语言实现是 RxJava，</p><p>ReactiveX 官方对 Rx 框架描述是：使用 “可观察流” 进行异步编程的 API，</p><p>翻译成人话即，响应式编程暗示人们 <strong>应当总是向数据源请求数据，然后在指定的观察者中响应数据的变化</strong>，</p><p>常见的 “响应式编程” 流程用伪代码表示如下：</p><p><img src="https://images.xiaozhuanlan.com/photo/2023/2050d3cfcc3d74a4fe4f357e8d624f1f.jpg" alt=""></p><h3 id="响应式编程的好处"><a href="#响应式编程的好处" class="headerlink" title="响应式编程的好处"></a>响应式编程的好处</h3><p>通过上述代码易得，在响应式编程下，业务逻辑在 ViewModel / Presenter 处集中管理，过程中向 UI 回推状态，且 UI 控件在指定的 “粘性观察者” 中响应，<strong>该模式下很容易做单元测试，有输入必有回响</strong>。</p><p>反之如像往常一样，将控件渲染代码分散在观察者以外的各个方法中，便很难做到这一点。</p><h3 id="响应式编程的漏洞"><a href="#响应式编程的漏洞" class="headerlink" title="响应式编程的漏洞"></a>响应式编程的漏洞</h3><p>随着业务发展，人们开始往 “粘性观察者” 回调中添加各种控件渲染，</p><p>如果同一控件实例（比如 textView）出现在不同粘性观察者回调中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">livedata_A.observe(<span class="hljs-keyword">this</span>, dataA -&gt;<br>textView.setText(dataA.b) <br>  ...<br>&#125;<br><br>livedata_B.observe(<span class="hljs-keyword">this</span>, dataB -&gt; <br>textView.setText(dataB.b) ⚠️<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>假设用户操作使得 textView 先接收到 liveData_B 消息，再接收到 liveData_A 消息，</p><p>那么旋屏重建后，由于 liveData_B 的注册晚于 liveData_A，textView 被回推的最后一次数据反而是来自 liveData_B，</p><p>给用户的感觉是，旋屏后展示老数据，不符预期。</p><h3 id="响应式编程的困境"><a href="#响应式编程的困境" class="headerlink" title="响应式编程的困境"></a>响应式编程的困境</h3><p>由此可得，响应式编程存在 1 个不显眼的关键细节：</p><p><strong>一个控件应当只在同一个观察者中响应</strong>，也即同一控件实例不该出现在多个观察者中。</p><p>但如果这么做，又会产生新的问题。由于页面控件往往多达十数个，如此观察者也需配上十数个。</p><p>是否存在某种方式，既能杜绝 “一个控件在多个观察者中响应”，又能消除与日俱增的观察者？答案是有 —— 即接下来我们介绍的 MVI。</p><h2 id="MVI-的存在意义"><a href="#MVI-的存在意义" class="headerlink" title="MVI 的存在意义"></a>MVI 的存在意义</h2><p>MVI 是 <strong>在响应式编程的前提下</strong>，通过 “将页面状态聚合” 来统一消除上述 2 个问题，</p><p>也即原先分散在各个 LiveData 中的 String、Boolean 等状态，现全部聚合到一个 JavaBean / data class 中，由唯一的粘性观察者回推，所有控件都在该观察者中响应数据的变化。</p><p>具体该如何实现？业界有个简单粗暴的解法 —— 遵循 “函数式编程思想”。</p><h2 id="MVI-的实现"><a href="#MVI-的实现" class="headerlink" title="MVI 的实现"></a>MVI 的实现</h2><h3 id="函数式编程思想"><a href="#函数式编程思想" class="headerlink" title="函数式编程思想"></a>函数式编程思想</h3><p>函数式编程的核心主要是纯函数，这种函数只有 “参数列表” 这唯一入口来传入初值，只有 “返回值” 这唯一出口来返回结果，且 <strong>“运算过程中” 不调用和影响函数作用域外的变量</strong>（也即 “无副作用”），</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span></span>&#123; <span class="hljs-comment">//纯函数</span><br><span class="hljs-keyword">return</span> b + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">changeA</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//非纯函数，因运算过程中调用和影响到外界变量 a</span><br>  <span class="hljs-keyword">int</span> c = a = calculate(b) <br>  <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">changeB</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//纯函数</span><br>  <span class="hljs-keyword">int</span> b = calculate(<span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">return</span> b + <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>显而易见，纯函数的好处是 <strong>“可以闭着眼使用”，有怎样的输入，必有怎样的输出</strong>，且过程中不会有预料外的影响发生。</p><p><img src="https://images.xiaozhuanlan.com/photo/2023/241c8150744ff760be6432e198c8e161.jpg" alt=""></p><p>这里贴一张网上盛传的图来说明 Model、View、Intent 三者关系，</p><p>笔者认为，MVI 并非真的 “纯函数实现”，而只是 “纯函数思想” 的实现，</p><p>也即我们实际上都是以 “面向对象” 方式在编程，从效果上达到 “纯函数” 即可，</p><p>反之如钻牛角尖，看什么都 “有副作用、不纯”，则易陷入悲观，忽视本可改善的环节，有点得不偿失。</p><h3 id="MVI-怎样实现纯函数效果"><a href="#MVI-怎样实现纯函数效果" class="headerlink" title="MVI 怎样实现纯函数效果"></a>MVI 怎样实现纯函数效果</h3><blockquote><p>Model 通常是继承 Jetpack ViewModel 来实现，负责处理业务逻辑；</p></blockquote><blockquote><p>Intent 是指发起本次请求的意图，告诉 Model 本次执行哪个业务。它可以携带或不带参数；</p></blockquote><blockquote><p>View 通常对应 Activity/Fragment，根据 Model 返回的 UiStates 进行渲染。</p></blockquote><p>也即我们让 Model 只暴露一个入口，用于输入 intent；只暴露一个出口，用于回调 UiStates；业务执行过程中不影响 UiStates 以外的结果；且 UiStates 的字段都设置为不可变（final / val）确保线程安全，即可达成 Model 的 “纯”，</p><p>Intent 达成 “纯” 比较简单，由于它只是个入参，字段都设置为不可变即可。</p><p>View 同样不难，只要确保 View 的入口就是 Model 的出口，也即 <strong>View 的控件都集中放置在 Model 的回调中渲染</strong>，即可达成 “纯”。</p><h3 id="存在哪些副作用"><a href="#存在哪些副作用" class="headerlink" title="存在哪些副作用"></a>存在哪些副作用</h3><h4 id="存在争议的副作用"><a href="#存在争议的副作用" class="headerlink" title="存在争议的副作用"></a>存在争议的副作用</h4><blockquote><p>那有人可能会说，“不对啊，View 在入口中调用了控件实例，也即函数作用域外的成员变量，是副作用呀” …… 笔者认为这是误解，</p></blockquote><p>因为 MVI 的 View 事实上就不是一个函数，而是一个类。如上文所述，MVI 实际上是 <strong>通过面向对象编程的方式实现 “纯函数” 效果</strong>，而非真的纯函数，</p><p>故我们可以站在类的角度重新审视 —— 控件是类成员，对应的是纯函数的自动变量，</p><p>换言之，控件渲染并没有调用和影响到 View 作用域外的元素，故不算副作用。</p><h4 id="公认的副作用"><a href="#公认的副作用" class="headerlink" title="公认的副作用"></a>公认的副作用</h4><p>与此同时，UiEvents 属于副作用，也即那些弹窗、页面跳转等 “一次性消费” 的情况，</p><p>为什么？笔者认为 “弹窗、页面跳转” 时，<strong>在当前 MVI-View 页面之外创建了新的 Window、或是在返回栈添加了新的页面</strong>，如此等于调用和影响了外界环境，所以这必是副作用，</p><blockquote><p>不过这是符合预期的副作用，对此官方 Guide 也有介绍 “将 UiEvents 整合到 UiStates” 的方式来改善该副作用：<a href="https://developer.android.google.cn/jetpack/guide/ui-layer/events#consuming-trigger-updates" target="_blank" rel="noopener">界面事件  | Android 开发者  | Android Developers</a></p></blockquote><p>与之相对的即 “不符预期的副作用” —— 例如控件实例被分散在观察者外的各个方法中，并在某个方法中被篡改和置空，其他方法并不知情，调用该实例即发生 NullPointException。</p><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>至此 MVI 的代码实现已呼之欲出：</p><p>1.创建一个 UiStates，反映当前页面的所有状态。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UiStates</span> </span>&#123;<br><span class="hljs-keyword">val</span> weather : Weather,<br>  <span class="hljs-keyword">val</span> isLoading : <span class="hljs-built_in">Boolean</span>,<br>  <span class="hljs-keyword">val</span> error : List&lt;UiEvent&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p>2.创建一个 Intent，用于发送请求时携带参数，和指明当前想执行的业务。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainPageIntent</span> </span>&#123;<br><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetWeather</span></span>(<span class="hljs-keyword">val</span> cityCode) : MainPageIntent()<br>&#125;<br></code></pre></td></tr></table></figure><p>3.执行业务的过程，总是先从数据层获取数据，然后根据情况分流和回推结果，例如请求成功，便执行 Success 来回推结果，请求失败，则 Error，对此业内普遍的做法是，增设一个 Actions，</p><p>并且由于 UiStates 的字段不可变，且控件集中响应 UiStates，也即务必确保 UiStates 的延续，由此每个业务带来局部改变时（partialChange），需通过 copy 等方式，将上一次的 UiStates 拷贝一份，并为对应字段注入 partialChange。这个过程业内称为 reduce。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainPageActions</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">reduce</span><span class="hljs-params">(oldStates : <span class="hljs-type">UiStates</span>)</span></span> : UiStates &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span>(<span class="hljs-keyword">this</span>)&#123;<br>      Loading -&gt; oldStates.copy(isLoading = <span class="hljs-literal">true</span>)<br>      <span class="hljs-keyword">is</span> Success -&gt; oldStates.copy(isLoading = <span class="hljs-literal">false</span>, weather = <span class="hljs-keyword">this</span>.weather)<br>      <span class="hljs-keyword">is</span> Error -&gt; oldStates.copy(isLoading = <span class="hljs-literal">false</span>, error = listOf(UiEvent(msg)))<br>    &#125;<br>  &#125;<br>  <br><span class="hljs-keyword">object</span> Loading : MainPageActions()<br><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Success</span></span>(<span class="hljs-keyword">val</span> weather : Weather) : MainPageActions()<br><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span></span>(<span class="hljs-keyword">val</span> msg : String) : MainPageActions()<br>&#125;<br></code></pre></td></tr></table></figure><p>4.创建当前页面使用的 MVI-Model。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainPageModel</span> : <span class="hljs-type">MVI_Model</span>&lt;<span class="hljs-type">UiStates</span>&gt;</span>() &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _stateFlow = MutableStateFlow(UiStates())<br>  <span class="hljs-keyword">val</span> stateFlow = _stateFlow.asStateFlow<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendResult</span><span class="hljs-params">(uiStates: <span class="hljs-type">S</span>)</span></span> = _stateFlow.emit(uiStates)<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">input</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>)</span></span> = viewModelScope.launch&#123; onHandle()&#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHandle</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>)</span></span> &#123;<br>    <span class="hljs-keyword">when</span>(intent)&#123;<br>    <span class="hljs-keyword">is</span> GetWeather -&gt; &#123;<br>        sendResult(MainPageActions.Loading.reduce(oldStates)<br>    <span class="hljs-keyword">val</span> response = api.post()<br>    <span class="hljs-keyword">if</span>(response.isSuccess) sendResult(<br>         MainPageActions.Success(response.<span class="hljs-keyword">data</span>).reduce(oldStates)<br>    <span class="hljs-keyword">else</span> sendResult(<br>         MainPageActions.Error(response.message).reduce(oldStates)<br>    &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.创建 MVI-View，并在 stateFlow 中响应 MVI-Model 数据。</p><p>控件集中响应，带来不必要的性能开销，需要做个 diff，只响应发生变化的字段。</p><blockquote><p>笔者通常是通过 DataBinding ObservableField 做防抖。后续如 Jetpack Compose 普及，建议是使用 Jetpack Compose，无需开发者手动 diff，其内部类似前端 DOM ，根据本次注入的声明树自行在内部差分合并渲染新内容。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainPageActivity</span> : <span class="hljs-type">Android_Activity</span></span>()&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> model : MainPageModel<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> views : MainPageViews<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>&#123;<br>    lifecycleScope.launch &#123;<br>    repeatOnLifecycle(Lifecycle.State.STARTED) &#123;<br>      model.stateFlow.collect &#123;uiStates -&gt;<br>  views.progress.<span class="hljs-keyword">set</span>(uiStates.isLoading)<br>  views.weatherInfo.<span class="hljs-keyword">set</span>(uiStates.weather.info)<br>        ...<br>      &#125;<br>    &#125;<br>    model.input(Intent.GetWeather(BEI_JING))<br>&#125;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainPageViews</span> : <span class="hljs-type">Jetpack_ViewModel</span></span>() &#123;<br><span class="hljs-keyword">val</span> progress = ObservableBoolean(<span class="hljs-literal">false</span>)<br>    <span class="hljs-keyword">val</span> weatherInfo = ObservableField&lt;String&gt;(<span class="hljs-string">""</span>)<br>    ...<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个流程用一张图表示即：</p><p><img src="https://images.xiaozhuanlan.com/photo/2023/6fd0916d7e35be85ccce2251118d073a.jpg" alt=""></p><h2 id="当下开发现状的反思"><a href="#当下开发现状的反思" class="headerlink" title="当下开发现状的反思"></a>当下开发现状的反思</h2><p>上文我们追溯了 MVI 来龙去脉，不难发现，MVI 是给 “响应式编程” 填坑的存在，通过状态聚合来消除 “不符预期回推、观察者爆炸” 等问题，</p><blockquote><p>然而 MVI 也有其不便之处，由于它本就是要通过聚合 UiStates 来规避上述问题，故 UiStates 很容易爆炸，特别是字段极多情况下，每次回推都要做数十个 diff ，在高实时场景下，难免有性能影响，</p></blockquote><p>MVI 许多页面和业务都需手写定制，难通过自动生成代码等方式半自动开发，故我们我们不如退一步，反思下为什么要用响应式编程？是否非用不可？</p><p>穷举所有可能，笔者觉得最合理的解释是，响应式编程十分便于单元测试 —— 由于控件只在观察者中响应，有输入必有回响，</p><p>也是因为这原因，官方出于完备性考虑，以响应式编程作为架构示例。</p><h3 id="从源头把问题消灭"><a href="#从源头把问题消灭" class="headerlink" title="从源头把问题消灭"></a>从源头把问题消灭</h3><p>现实情况往往复杂。</p><p>Android 最初为了站稳脚跟，选择复用已有的 Java 生态和开发者，乃至使用 Java 作为官方语言，后来 Java 越来越难支持现代化移动开发，故而转向 Kotlin，</p><p>Kotlin 开发者更容易跟着官方文档走，一开始就是接受 Flow 那一套，且 Kotlin 抹平了语法复杂度，天然适合 “响应式编程” 开发，如此便有机会踩坑，乃至有动力通过 MVI 来改善。</p><blockquote><p>然而 10 个 Android 7 个纯 Java ，其中 6 个从不用 RxJava ，剩下一个还是偶尔用用 RxJava 的线程调度切换，所以响应式编程在 Android Java 开发者中的推行不太理想，领导甚至可能为了照顾多数同事，而要求撤回响应式代码，如此便很难有机会踩坑，更谈不上使用 MVI，</p></blockquote><p>也因此，实际开发中更多考虑的是，如何从根源上避免各种不可预期问题。</p><p>对此从软件工程角度出发，笔者在设计模式原则中找到答案 —— 任何框架，<strong>只要遵循单一职责原则，便能有效避免各种不可预期问题</strong>，反之过度设计则易引发不可预期问题。</p><h3 id="什么是过度设计，如何避免"><a href="#什么是过度设计，如何避免" class="headerlink" title="什么是过度设计，如何避免"></a>什么是过度设计，如何避免</h3><p>上文提到的 “粘性观察者”，对应的是 BehaviorSubject 实现，强调 “总是有一个状态”，比如门要么是开着，要么是关着，门在订阅 BehaviorSubject 时，会被自动回推最后一次 State 来反映状态。</p><p>常见 BehaviorSubject 实现有 ObservableField、LiveData、StateFlow 等。</p><p>反之是 PublishSubject 实现，对应的是一次性事件，常见 PublishSubject 实现有 SharedFlow 等。</p><blockquote><p>笔者认为，LiveData/StateFlow 存在过度设计，因为它的观察者是开放式，一旦开了这口子，后续便不可控，一个良好的设计是，<strong>不暴露不该暴露的口子，不给用户犯错的机会</strong>。</p></blockquote><p>一个正面的案例是 DataBinding observableField，不向开发者暴露观察者，且一个控件只能在 xml 中绑定一个，从根源上杜绝该问题。</p><h3 id="平替方案的探索"><a href="#平替方案的探索" class="headerlink" title="平替方案的探索"></a>平替方案的探索</h3><p>至此平替方案便也呼之欲出 —— 使用 ObservableField 来承担 BehaviorSubject，</p><p>也即直接在 ViewModel 中调用 ObservableField 通知所绑定的控件响应，且每个 ObservableField 都携带原子数据类型（例如 String、Boolean 等类型），</p><p>如此便无需声明 UiStates 数据类。由于无 UiStates、无聚合、也无线程安全问题，也就无需再 reduce 和 diff，简单做个 Actions 为结果分流即可。</p><p><img src="https://images.xiaozhuanlan.com/photo/2023/9951b6af28b0cdf0b46f58fe77c1420a.jpg" alt=""></p><p>此时仍属响应式编程，相较经典 MVI，繁琐度大幅缩减，性能有所提升。</p><h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p>响应式编程便于单元测试，但其自身存在漏洞，MVI 即是来消除漏洞，</p><p>MVI 有一定门槛，实现较繁琐，且存在性能等问题，难免同事撂挑子不干，一夜回到解放前，</p><p>综合来说，MVI 适合与 Jetpack Compose 搭配实现 “现代化的开发模式”，</p><p>反之如追求 “低成本、复用、稳定”，可通过遵循 “单一职责原则” 从源头把问题消除。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>响应式编程：<a href="https://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a></p><p>函数式编程：<a href="https://zh.wikipedia.org/wiki/函数式编程" target="_blank" rel="noopener">函数式编程 - 百科</a></p><p>MVI 纯函数图例：<a href="http://hannesdorfmann.com/android/mosby3-mvi-2/" target="_blank" rel="noopener">Reactive Apps with Model-View-Intent - Part 2: View and Intent</a></p><p>通过 UiStates 管理 UiEvent：<a href="https://developer.android.google.cn/jetpack/guide/ui-layer/events#consuming-trigger-updates" target="_blank" rel="noopener">界面事件 | Android Developers</a></p><p>平替方案探索：<a href="https://juejin.cn/post/7134594010642907149" target="_blank" rel="noopener">解决 MVI 架构实战痛点</a></p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><blockquote><p>Copyright © 2019-present KunMinX 原创版权所有。</p></blockquote><p>如需 <strong>转载本文，或引用、借鉴</strong> 本文 “引言、思路、结论、配图” 进行二次创作发行，<strong>须注明链接出处</strong>，否则我们保留追责权利。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;学技术要学本质。对 MVI 的有效理解，源于对 “响应式编程 作用和漏洞” 等关键细节的挖掘，&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>通俗易懂 Android 架构组件发展史</title>
    <link href="https://www.kunminx.com/2022/09/20/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%20Android%20%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
    <id>https://www.kunminx.com/2022/09/20/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%20Android%20%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%8F%91%E5%B1%95%E5%8F%B2/</id>
    <published>2022-09-20T04:00:00.000Z</published>
    <updated>2023-07-25T11:03:50.396Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>谈到 Android 架构，相信谁都能说上两句。从 MVC，MVP，MVVM，再到时下兴起 MVI，架构设计层出不穷。如何为项目选择合适架构，也成常备课题。</p><p>由于架构并非空穴来风，每一种设计都有其存在依据。故今天我们一起探寻 “架构演化” 来龙去脉，相信阅读后你会豁然开朗。</p><h2 id="文章目录一览"><a href="#文章目录一览" class="headerlink" title="文章目录一览"></a>文章目录一览</h2><ul><li>前言</li><li>原生架构<ul><li>原始图形化架构<ul><li>高频痛点 1：Null 安全一致性问题</li></ul></li><li>原始工程架构 MVC<ul><li>高频痛点 2：成员变量爆炸</li><li>高频痛点 3：状态管理一致性问题</li><li>高频痛点 4：消息分发一致性问题</li></ul></li></ul></li><li>它山之石<ul><li>矫枉过正 MVP<ul><li>反客为主 Presenter</li><li>简明易用 三方库</li></ul></li><li>拨乱反正 MVVM<ul><li>曲高和寡 DataBinding</li><li>未卜先知 mBinding</li></ul></li></ul></li><li>力挽狂澜<ul><li>官方牵头 Jetpack<ul><li>一举多得 ViewModel</li></ul></li><li>半路杀出 Kotlin<ul><li>喜闻乐见 ViewBinding</li></ul></li></ul></li><li>百花齐放<ul><li>最佳实践 Jetpack MVVM<ul><li>屏蔽回推 UnPeekLiveData</li><li>消息分发 Dispatcher</li><li>严格模式 DataBinding </li></ul></li><li>另起炉灶 Compose</li></ul></li><li>综上</li></ul><h2 id="原生架构"><a href="#原生架构" class="headerlink" title="原生架构"></a>原生架构</h2><h3 id="原始图形化架构"><a href="#原始图形化架构" class="headerlink" title="原始图形化架构"></a>原始图形化架构</h3><p>完整软件服务，通常包含客户端和服务端。</p><p>Linux 服务端，开发者通过命令行操作；Android 客户端，面向普通用户，须提供图形化操作。为此，Android 将图形系统设计为，通过客户端 Canvas 绘制图形，并交由 Surface Flinger 渲染。</p><p>但正如<a href="https://www.yuque.com/kunminx/fpmbc5/tpn54e" target="_blank" rel="noopener">《过目难忘 Android GUI 关系梳理》</a>所述，复杂图形绘制离不开排版过程，而开发者良莠不齐，如直接暴露 Canvas，易导致开发者误用和产生不可预期错误，</p><p>为此 Android 索性基于 “模板方法模式” 设计 View、Drawable 等排版模板，让 UI 开发者可继承标准化模板，配置出诸如 TextView、ImageView、ShapeDrawable 等自定义模板，供业务开发者用。</p><blockquote><p>这样误用 Canvas 问题看似解决，却引入 “高频痛点 1”：<strong>View 实例 Null 安全一致性问题</strong>。这是 Java 语言项目硬伤，客户端背景下尤明显。</p></blockquote><h4 id="高频痛点-1：Null-安全一致性问题"><a href="#高频痛点-1：Null-安全一致性问题" class="headerlink" title="高频痛点 1：Null 安全一致性问题"></a>高频痛点 1：Null 安全一致性问题</h4><p>例如某页面有横竖两布局，竖布局有 TextViewA，横布局无，那么横屏时，findViewbyId 拿到则是 Null 实例，后续 <code>mTextViewA.setText( )</code> 如未判空处理，即造成 Null 安全问题，</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/65d68f299de4f66762bac61910398cb0.png" alt=""></p><p>对此不能一味强调 “手动判空”，毕竟一个页面中，控件成员多达十数个，每个控件实例亦遍布数十方法中。疏忽难避免。</p><blockquote><p>那怎办？此时 2008 年，回顾历史，可总结为：“同志们，7 年暗夜已开始，7 年后会有个框架，驾着七彩祥云来救你”。</p></blockquote><h3 id="原始工程架构-MVC"><a href="#原始工程架构-MVC" class="headerlink" title="原始工程架构 MVC"></a>原始工程架构 MVC</h3><p>时间来到 2013，以该年问世 Android Studio 为例，</p><p>工程结构主要包含 Java 代码和 res 资源。考虑到布局编写预览需求，Android 开发默认基于 XML 声明 Layout，MVC 形态油然而生，</p><blockquote><p>其中 XML 作 View 角色，供 View-Controller 获取实例和控制，</p></blockquote><blockquote><p>Activity 作 View-Controller 角色，结合 View 和 Model 控制逻辑，</p></blockquote><blockquote><p>开发者另外封装 DataManager，POJO 等，作 Model 角色，用于数据请求响应，</p></blockquote><p>显而易见，该架构实际仅两层：控制层和数据层，</p><p>Activity 越界承担 “领域层” 业务逻辑职责，也因此滋生如下 3 个高频痛点：</p><h4 id="高频痛点-2：成员变量爆炸"><a href="#高频痛点-2：成员变量爆炸" class="headerlink" title="高频痛点 2：成员变量爆炸"></a>高频痛点 2：成员变量爆炸</h4><p>成员声明，动辄数十行，令人眼花缭乱。接手老项目开发者，最有体会。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/1ad80e1ae477a02bc03958e5be1e3593.png" alt=""></p><h4 id="高频痛点-3：状态管理一致性问题"><a href="#高频痛点-3：状态管理一致性问题" class="headerlink" title="高频痛点 3：状态管理一致性问题"></a>高频痛点 3：状态管理一致性问题</h4><p>View 状态保存和恢复，使用原生 onInstanceStateSave &amp; Restore 机制，开发者容易因 “记得 restore、遗漏 save” 而产生不可预期错误。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/8f7e0cc9ec58209d80bdccb3e4217dcf.png" alt=""></p><h4 id="高频痛点-4：消息分发一致性问题"><a href="#高频痛点-4：消息分发一致性问题" class="headerlink" title="高频痛点 4：消息分发一致性问题"></a>高频痛点 4：消息分发一致性问题</h4><p>由于 Activity 额外承担 “领域层” 职责，乃至消息收发工作也直接在 Activity 内进行，这使消息来源无法保证时效性、一致性，易 “被迫收到” 不可预期推送，滋生千奇百怪问题。</p><p>EventBus 等 “缺乏鉴权结构” 框架，皆为该背景下 “消息分发不一致” 帮凶。</p><blockquote><p>“同志们，5 年水深火热已过去，再过 2 年，曙光降临”</p><p>好家伙，这是提前拿到剧本。既然如此，这 2 年时间，不如放开手脚，引入它山之石试试（<del>就逝世</del>）。</p></blockquote><h2 id="它山之石"><a href="#它山之石" class="headerlink" title="它山之石"></a>它山之石</h2><h3 id="矫枉过正-MVP"><a href="#矫枉过正-MVP" class="headerlink" title="矫枉过正 MVP"></a>矫枉过正 MVP</h3><p>这一版对 “现实状况” 判断有偏差。</p><p>MVP 规定 Activity 应充当 View，而 Presenter 独吞 “表现层” 逻辑，通过 “契约接口” 与 View、Model 通信，</p><p>这使 Activity 职能被严重剥夺，只剩末端通知 View 状态改变，无法全权自治 “表现逻辑”。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/45757847a65ae15afb4ecc9d79180f5e.png" alt=""></p><h4 id="反客为主-Presenter"><a href="#反客为主-Presenter" class="headerlink" title="反客为主 Presenter"></a>反客为主 Presenter</h4><p>从 Presenter 角度看，似乎遵循 “依赖倒置原则” 和 “最小知道原则”，但从关系界限层面看，Presenter 属 “空降” 角色，一切都其自作主张、暗箱操作，不仅 “未能实质解决” 原 Activity 面临上述 4 大痛点，反因贪婪夺权引入更多烂事。</p><p>这也是为何，开发过 MVP 项目，都知有多别扭。</p><h4 id="简明易用-三方库"><a href="#简明易用-三方库" class="headerlink" title="简明易用 三方库"></a>简明易用 三方库</h4><p>基于其本质 “依赖倒置原则” 和 “最小知道原则”，更建议将其用于 “局部功能设计”，如 “三方库” 设计，使开发者 <strong>无需知道内部逻辑，简单配置即可使用</strong>。</p><blockquote><p><a href="https://github.com/KunMinX/Linkage-RecyclerView" target="_blank" rel="noopener">Github：Linkage-RecyclerView</a></p><p>我们维护的 “饿了么二级联动列表” 库，即是基于该模式设计，感兴趣可自行查阅。</p></blockquote><h3 id="拨乱反正-MVVM"><a href="#拨乱反正-MVVM" class="headerlink" title="拨乱反正 MVVM"></a>拨乱反正 MVVM</h3><p>经历漫长黑夜，Android 开发引来曙光。</p><p>2015 年 Google I/O 大会，DataBinding 框架面世。</p><p>该框架可用于解决 “<strong>高频痛点1：View 实例 Null 安全一致性问题</strong>”，并跟随 MVVM 模式步入开发者视野。</p><h4 id="曲高和寡-DataBinding"><a href="#曲高和寡-DataBinding" class="headerlink" title="曲高和寡 DataBinding"></a>曲高和寡 DataBinding</h4><blockquote><p>MVVM 是种约定，双向绑定是 MVVM 特征，但非 DataBinding 本质，故长久以来，开发者对 DataBinding 存在误解，认为使用 DataBinding 即须双向绑定、且在 XML 中调试。</p></blockquote><p>事实并非如此。</p><p>DataBinding 是通过 “可观察数据 ObservableField” 在编译时与 XML 中对应 View 实例绑定，这使上文所述 “竖布局有 TextViewA 而横布局无” 情况下，有 TextViewA 即被绑定，无即无绑定，于是无论何种情况，都不至于 findViewById 拿到 Null 实例从而诱发 Null 安全问题。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/3070a716be4b8f82c000802d33f8ba82.png" alt=""></p><p>也即，<strong>DataBinding 仅负责通知末端 View 状态改变，仅用于规避 Null 安全问题</strong>，不参与视图逻辑。而反向绑定是 “迁就” 这一结构的派生设计，非核心本质。</p><blockquote><p>碍于篇幅限制，如这么说无体会，可参见<a href="https://xiaozhuanlan.com/topic/9816742350" target="_blank" rel="noopener">《从被误解到 “真香” Jeptack DataBinding》</a>解析，本文不再累述。</p></blockquote><h4 id="未卜先知-mBinding"><a href="#未卜先知-mBinding" class="headerlink" title="未卜先知 mBinding"></a>未卜先知 mBinding</h4><p>除了本质难理解，DataBinding 也有硬伤，由于隔着一层 BindingAdapter，难获取 View 体系坐标等 getter 属性，乃至 “属性动画” 等框架难兼容。</p><blockquote><p>有说 MotionLayout 可破此局，于多数场景轻松完成动画。</p><p>但它也非省油灯，不同时支持 Drag &amp; Click，难实现我们 <a href="https://juejin.cn/post/6844903986475040782#heading-0" target="_blank" rel="noopener">示例项目</a> “展开面板” 场景。</p></blockquote><p>于是，DataBinding 做出 “违背祖宗” 决定 —— <strong>允许开发者在 Java 代码中拿到 mBinding 乃至 View 实例</strong> …  如此上一节提到的 “改用 ObservableField 的绑定来消除 Null 安全问题” 的努力前功尽弃。</p><p>—— 鉴于 App 页面并非总是 “横竖布局皆有”，于是开发者索性通过 “强制竖屏” 扼杀 View 实例 Null 安全隐患，而调用 mBinding 实例仅用于规避 findViewById 样板代码。</p><blockquote><p>至于为何说 mBinding 使用即 “未卜先知”，因为群众智慧多年后即被应验。</p></blockquote><h2 id="力挽狂澜"><a href="#力挽狂澜" class="headerlink" title="力挽狂澜"></a>力挽狂澜</h2><h3 id="官方牵头-Jetpack"><a href="#官方牵头-Jetpack" class="headerlink" title="官方牵头 Jetpack"></a>官方牵头 Jetpack</h3><p>时间回到 2017，这年 Google I/O 引入一系列 AAC（Android Architecture Components）</p><h4 id="一举多得-ViewModel"><a href="#一举多得-ViewModel" class="headerlink" title="一举多得 ViewModel"></a>一举多得 ViewModel</h4><p>其中 Jetpack ViewModel，通过支持 View 实例状态 “托管” 和 “保存恢复”，</p><p>一举解决 “<strong>高频痛点2：成员变量爆炸</strong>” 和 “<strong>高频痛点 3：状态管理一致性问题</strong>”，</p><p>Activity 成员变量表，一下简洁许多。Save &amp; Restore 样板代码亦烟消云散。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/9d2615c37a7c3ee6af756bb26318a004.png" alt=""></p><h3 id="半路杀出-Kotlin"><a href="#半路杀出-Kotlin" class="headerlink" title="半路杀出 Kotlin"></a>半路杀出 Kotlin</h3><p>并且这时期，Kotlin 被扶持为官方语言，背景发生剧变。</p><p>Kotlin 直接从语言层面支持 Null 安全，于是 DataBinding 在 Kotlin 项目式微。</p><h4 id="喜闻乐见-ViewBinding"><a href="#喜闻乐见-ViewBinding" class="headerlink" title="喜闻乐见 ViewBinding"></a>喜闻乐见 ViewBinding</h4><p>千呼万唤，ViewBinding 问世 2019。</p><p>如布局中 View 实例隐含 Null 安全隐患，则编译时 ViewBinding 中间代码为其生成 @Nullable 注解，使 Kotlin 开发过程中，Android Studio 自动提醒 “强制使用 Null 安全符”，由此确保 Null 安全一致。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/ac41859aafacf170d157f95ff7a34cae.png" alt=""></p><p>ViewBinding 于 Kotlin 项目可平替 DataBinding，开发者喜闻乐见 mBinding 使用。</p><h2 id="百花齐放"><a href="#百花齐放" class="headerlink" title="百花齐放"></a>百花齐放</h2><h3 id="最佳实践-Jetpack-MVVM"><a href="#最佳实践-Jetpack-MVVM" class="headerlink" title="最佳实践 Jetpack MVVM"></a>最佳实践 Jetpack MVVM</h3><p>自 2017 年 AAC 问世，部分原生 Jetpack 架构组件至今仍存在设计隐患，</p><p>基于 “架构组件本质即解决一致性问题” 理解，我们于 2019 陆续将 “隐患组件” 改造和开源。</p><p><strong>Note 2023.4.25 加餐：</strong></p><h4 id="屏蔽回推-UnPeekLiveData"><a href="#屏蔽回推-UnPeekLiveData" class="headerlink" title="屏蔽回推 UnPeekLiveData"></a>屏蔽回推 UnPeekLiveData</h4><p>LiveData 是效仿响应式编程 BehaviorSubject 的设计，由于</p><p>1.Jetpack 架构示例通常只包含 “表现层” 和 “数据层” 两层，缺乏在 “领域层” 分发数据的工具，</p><p>2.LiveData Observer 的设计缺乏边界感，</p><p>容易让开发者误当做 “一次性事件分发组件” 来使用，造成订阅时 “自动回推脏数据”；</p><p>容易让开发者误将同一控件实例放在多个 Observer 回调中 造成恢复状态时 “数据不一致” 等问题（具体可参见<a href="https://xiaozhuanlan.com/topic/4689175032" target="_blank" rel="noopener">《响应式编程和 MVI》篇</a> 关于 “响应式编程漏洞” 的描述）</p><p>3.DataBinding ObservableField 组件的 Observer 能限定为 “与控件一对一绑定”，更适合承担表现层 BehaviorSubject 工作，</p><p>4.LiveData 具备生命周期安全等优势，</p><p>因此决定将 LiveData 往领域层 PublishSubject 方向改造，去除其 “自动推送最后一次状态” 的能力，使其专职生命周期安全的数据分发。</p><blockquote><p>具体可参见 <a href="https://github.com/KunMinX/UnPeek-LiveData" target="_blank" rel="noopener">Github：UnPeek-LiveData</a> 使用。</p></blockquote><p><strong>Note 2023.4.25 加餐：</strong></p><h4 id="消息分发-Dispatcher"><a href="#消息分发-Dispatcher" class="headerlink" title="消息分发 Dispatcher"></a>消息分发 Dispatcher</h4><p>由于 LiveData 存在的初衷并非是专业的 “一次性事件分发组件”，改造过的 UnPeekLiveData 也只适用于 “低频次数据分发（例如每秒推送 1 次）” 场景，</p><p>因而若想满足 “高频次事件分发” 需求（例如每秒推送 5 次以上），请改用或参考专职 “领域层” 数据分发的 <a href="https://github.com/KunMinX/MVI-Dispatcher" target="_blank" rel="noopener">Github：MVI-Dispatcher</a> 组件，该组件内部通过消息队列设计，确保不漏掉每一次推送。</p><p><img src="https://images.xiaozhuanlan.com/photo/2023/16ca7da0028a3cd71a91817365149017.jpg" alt=""></p><blockquote><p>Dispatcher 的存在解决了 “<strong>高频痛点 4：消息分发一致性问题</strong>”，</p><p>也即通过在领域层设立 “专职业务处理和结果回推” 的 Dispatcher，来将业务处理过程中产生的 Event 或 State，以串流的方式统一从 output 出口回传，</p><p>由此表现层页面可根据消息的性质，采取 “一致性执行” 或 “交由 BehaviorSubject 托管状态”。</p><p>对此具体可参见<a href="https://xiaozhuanlan.com/topic/6741932805" target="_blank" rel="noopener">《Jetpack MVVM 分层设计解析》篇</a> 解析。</p></blockquote><h4 id="严格模式-DataBinding"><a href="#严格模式-DataBinding" class="headerlink" title="严格模式 DataBinding"></a>严格模式 DataBinding</h4><p>此外我们明确约定 Java 下 DataBinding 使用原则，确保 100% Null 安全。如违背原则，便 Debug 模式下警告，方便开发者留意。</p><blockquote><p>具体可参见 <a href="https://github.com/KunMinX/Jetpack-MVVM-Best-Practice/blob/master/app/src/main/java/com/kunminx/puremusic/ui/page/SearchFragment.java" target="_blank" rel="noopener">Github：KunMinX-MVVM</a> 使用。</p></blockquote><h3 id="另起炉灶-Compose"><a href="#另起炉灶-Compose" class="headerlink" title="另起炉灶 Compose"></a>另起炉灶 Compose</h3><p>回到文章开头 Canvas，为实现 View 实例 Null 安全，先是 DataBinding 框架，但它作为一框架，并不体系自洽，与 “属性动画” 等框架难兼容。</p><p>于是出现声明式 UI，通过函数式编程 “<strong>纯函数原子性</strong>” 解决 Null 安全一致。且体系自洽，动画无兼容问题，学习成本也低于 View 体系。</p><p>后续如性能全面跟上、120Hz 无压力，建议直接上手 Compose 开发。</p><blockquote><p>注：关于声明式 UI 函数式编程本质，及纯函数原子性为何能实现 Null 安全一致，详见<a href="https://www.yuque.com/kunminx/fpmbc5/nrvuk0" target="_blank" rel="noopener">《一通百通 “声明式 UI” 扫盲干货》</a>，本文不作累述。</p></blockquote><h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p><strong>高频痛点1：Null 安全一致性问题</strong></p><p>客户端，图形化，需 Canvas，</p><p>为避免接触 Canvas 导致不可预期错误，原生架构提供 View、Drawable 排版模板，</p><p>为解决 Java 下 View 实例 Null 安全一致性问题，引入 DataBinding，</p><p>但 DataBinding 仅是一框架，难体系自洽，</p><p>于是兵分两路，Kotlin + ViewBinding 或 Kotlin + Compose 取代 DataBinding。</p><p><strong>高频痛点2：成员变量爆炸</strong></p><p><strong>高频痛点3：状态管理一致性问题</strong></p><p>引入 Jetpack ViewModel，实现状态托管和保存恢复。</p><p><strong>高频痛点4：消息分发一致性问题</strong></p><p>引入 Dispatcher 承担 PublishSubject，实现统一的消息推送。</p><p>最后，天下无完美架构，唯有高频痛点熟稔于心，不断死磕精进，集思广益，迭代特定场景最优解。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>Canvas，View，Drawable，排版模板：<a href="https://www.yuque.com/kunminx/fpmbc5/tpn54e" target="_blank" rel="noopener">《过目难忘 Android GUI 关系梳理》</a></p><p>DataBinding，Null 安全一致，ViewBinding：<a href="https://xiaozhuanlan.com/topic/9816742350" target="_blank" rel="noopener">《从被误解到 “真香” Jetpack DataBinding》</a></p><p>Dispatcher，消息分发，State，Event：<a href="https://xiaozhuanlan.com/topic/6741932805" target="_blank" rel="noopener">《Jetpack MVVM 分层设计解析》</a> </p><p>架构组件解决一致性问题：<a href="https://juejin.cn/post/6844903976240939021" target="_blank" rel="noopener">《耳目一新 Jetpack MVVM 精讲》</a></p><p>Compose，纯函数原子特性，Null 安全一致：<a href="https://www.yuque.com/kunminx/fpmbc5/nrvuk0" target="_blank" rel="noopener">《一通百通 “声明式 UI” 扫盲干货》</a></p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><blockquote><p>Copyright © 2019-present KunMinX 原创版权所有。</p></blockquote><p>如需 <strong>转载本文，或引用、借鉴</strong> 本文 “引言、思路、结论、配图” 进行二次创作发行，<strong>须注明链接出处</strong>，否则我们保留追责权利。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;谈到 Android 架构，相信谁都能说上两句。从 MVC，MVP，MVVM，再到时下兴起 MVI</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于第一性原理</title>
    <link href="https://www.kunminx.com/2021/02/05/%E5%85%B3%E4%BA%8E%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86/"/>
    <id>https://www.kunminx.com/2021/02/05/%E5%85%B3%E4%BA%8E%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86/</id>
    <published>2021-02-05T02:00:00.000Z</published>
    <updated>2023-07-25T07:11:11.310Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于知识深度和广度，一直众口不一，</p><p>例如总有这样的声音，认为客户端 App 开发就是没深度，Framework 开发就是有深度；关注业务逻辑就是没深度，琢磨底层原理才是有深度 …</p><h2 id="广度"><a href="#广度" class="headerlink" title="广度"></a>广度</h2><p>没懂造成这些观点的依据是什么，</p><p>笔者认为，应用层和框架层，只是分属两个不同的领域，都是由各个知识点拼接而成，彼此之间并无谁深谁浅之分，</p><p>如果开发者学习了应用层，又学习了框架层，本质上只是拓宽了广度，从研究 “茴” 有几种写法，到研究 “龍” 有几种写法；从研究 kotlin 语法有哪些，到研究 C++ 服务有哪些而已，</p><h2 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h2><p>易得学习和接受某领域知识，只是单纯的成长、增长见识和经验，但谈不上思想更深邃，</p><p>那么造成 “深度、广度” 区别的关键在于什么，</p><p>笔者认为，基于 “第一性原理” 进行推理的思考过程，才有机会构成 “深度理解”，这是一个 “逆向推理 + 正向推理” 的过程，通过不断反思：</p><blockquote><p>“该事物的存在缘由是什么，当初是为解决何种场景下的何种需求，问世的该事物。如今时过境迁，该场景该需求是否还在，新场景新需求又如何。在新场景新需求情况下，有无低成本的更优解”</p></blockquote><p>来达成对事物本质的理解、解决方案的举一反三，以及独具一格的颠覆式创新，</p><p>也即，从学习 “龍” 的几种写法，到发明 “龙” 的新写法；从学习 Unix 的使用，到另起炉灶手写一个 Linux 内核；从学习传统火箭的发射方式，到离经叛道 “可回收式火箭” —— 唯追根溯源，抓住本质，方才有机会根据 “新的场景” 推陈出新，</p><p>做到这份上，才算有深度、是真的真的理解，否则充其量只是新手，浮于表面，略知一二，</p><h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p>物质世界过于纷繁，我们不可能也没必要事事都做到 “有深度”，</p><p>大部分情况下，光是学习和成长，就已经能过上相对不错的生活，</p><p>如对某领域有兴趣、有追求，不妨根据上述思考方式，追根溯源，假以时日，必能在某领域有所建树。</p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><blockquote><p>Copyright © 2019-present KunMinX 原创版权所有。</p></blockquote><p>如需 <strong>转载本文，或引用、借鉴</strong> 本文 “引言、思路、结论、配图” 进行二次创作发行，<strong>须注明链接出处</strong>，否则我们保留追责权利。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于知识深度和广度，一直众口不一，&lt;/p&gt;
&lt;p&gt;例如总有这样的声音，认为客户端 App 开发就是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>声明式 UI 解析</title>
    <link href="https://www.kunminx.com/2020/03/06/%E5%A3%B0%E6%98%8E%E5%BC%8F%20UI%20%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.kunminx.com/2020/03/06/%E5%A3%B0%E6%98%8E%E5%BC%8F%20UI%20%E8%A7%A3%E6%9E%90/</id>
    <published>2020-03-06T12:00:00.000Z</published>
    <updated>2023-07-25T07:02:29.103Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>注：本文节选自<a href="https://xiaozhuanlan.com/topic/2356748910" target="_blank" rel="noopener">《重学安卓：一通百通 “声明式 UI” 扫盲干货》</a>，本文可免费阅读和全文转载，转载时须注明本文链接出处。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Canvas 总共生两胎，一胎 View 体系，二胎 Compose 体系，</p></blockquote><p>上一期<a href="https://xiaozhuanlan.com/topic/2073915486" target="_blank" rel="noopener">《过目难忘 Android GUI 关系梳理》</a>，我们循序渐进拆解了 “View 体系” 各工具的 <strong>存在意义 及 相互间关系</strong>，鉴于 Compose 离 “普及” 还有很长距离，这一期我们先来介绍 Compose 框架背后的本质。</p><h2 id="声明式-UI-由来"><a href="#声明式-UI-由来" class="headerlink" title="声明式 UI 由来"></a>声明式 UI 由来</h2><p>事实上，React、Flutter、SwiftUI、Jetpack Compose，这些 UI 框架有个共同鼻祖，即一个名为 elm（不是 “饿了么”）的 UI 框架，是它最早确立并推行 “声明式 UI” 设计理念。</p><blockquote><p>注：“声明式 UI” 这个名称，最初谁定义，暂未找到来源，目前各大官网都称其为 “声明式 UI”，基于我个人理解，其更精确表达是，“响应式 UI 框架的声明式编程分支”，当然，最终我们还是简称为 “声明式 UI”。</p></blockquote><p>—— 那么 “声明式 UI” 到底长啥样？为何要用 “声明式 UI”？相比传统 View 有何优势？本质、存在意义又是什么？</p><p>—— React、Flutter、SwiftUI、Jetpack Compose，形态各异，如何透过表象看穿流程机制，从而自行领悟代码 该怎么写、往哪写、怎么改？</p><p>所以今天我们就来统一解析 “声明式 UI” 背后本质，相信阅读后能让你醍醐灌顶。</p><h2 id="文章目录一览"><a href="#文章目录一览" class="headerlink" title="文章目录一览"></a>文章目录一览</h2><ul><li>前言</li><li>声明式 UI 由来</li><li>声明式 UI 本质是 “函数式 + 函数式编程”<ul><li>“纯函数” 是 “函数式编程” 基石</li><li>“函数式编程” 引入前的混沌世界</li><li><strong>“函数式编程” 为何能 “彻底” 解决这类问题？</strong></li><li>引入 “函数式编程” 后的世界</li></ul></li><li>所以为什么会有 “声明式 UI 框架”？<ul><li><strong>声明式 UI 运作流程是怎样</strong></li><li><strong>声明式 UI 难以替代的好处</strong></li></ul></li><li>函数式编程局限</li><li><strong>Note 2020.07.27 加餐：</strong></li><li>现有条件下 “View 实例 Null 安全一致性问题” 最优解<ul><li>1.Java + DataBinding 严格模式</li><li>2.Kotlin + ViewBinding</li><li>3.Kotlin DSL 动态布局</li><li><strong>Note 2022.06.06 加餐</strong></li></ul></li><li>Note 2020.07.31 加餐：<ul><li>通过 “函数式编程思想” 秒懂 “声明式 UI” 打开方式</li></ul></li><li>综上</li></ul><h2 id="声明式-UI-本质是-“函数式-响应式编程”"><a href="#声明式-UI-本质是-“函数式-响应式编程”" class="headerlink" title="声明式 UI 本质是 “函数式 + 响应式编程”"></a>声明式 UI 本质是 “函数式 + 响应式编程”</h2><p>声明式 UI、Java8 Stream、RxJava 等，本质上皆是函数式编程 + 响应式编程。</p><p>许多文章，从 RxJava 时代起，就照搬官网说法，说 RxJava 是一种 “响应式编程” 框架。</p><p>事实上，“响应式编程” 是从 “整体流程数据走向” 的角度来看 —— “输入数据，响应结果”，单凭 “响应式编程” 无益于更好理解 “声明式 UI” 和其他 UI 框架的本质区别，</p><p>所以，我们不妨重点关注另一个核心本质 —— 函数式编程。</p><h3 id="“纯函数”-是-“函数式编程”-基石"><a href="#“纯函数”-是-“函数式编程”-基石" class="headerlink" title="“纯函数” 是 “函数式编程” 基石"></a>“纯函数” 是 “函数式编程” 基石</h3><p>老规矩，先讲结论：</p><blockquote><p><strong>声明式 UI 的内部实现是基于函数式编程，且函数式编程基石是纯函数</strong>，</p><p>函数式编程的存在，主要是通过 “流程的原子化” 实现 “结果的一致性”，</p><p>声明式 UI 框架可将多种一致性问题简化为只关注 “数据的一致性问题”，</p></blockquote><p>上述三点，如暂无体会，那接下来，请跟随我脚步铺垫 “声明式 UI” 来龙去脉。</p><h3 id="“函数式编程”-引入前的混沌世界"><a href="#“函数式编程”-引入前的混沌世界" class="headerlink" title="“函数式编程” 引入前的混沌世界"></a>“函数式编程” 引入前的混沌世界</h3><p>以下是常见用法：</p><p>通过 findViewById 拿到 TextView 实例，使其作为 Activity 内部共享成员变量，为多个方法所调用，来改变 TextView 状态。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/1889f3a3310af0351ba8fe2d1ed83a97.png" alt="img"></p><p>这造成什么问题？</p><p><strong>一旦 TextView 成为 Activity 类的成员变量，分散到各方法中，后续便不可控</strong>，因为执行方法 B 时，方法 A 无法知道 方法 B 中对成员变量做了什么，却无差别承受 “成员变量被修改” 所带来影响，</p><p>例如当 方法 B 将 TextView 置空，那么 方法 A 调用 TextView 实例时 将面临 Null 安全问题。</p><blockquote><p>可能有人会问，这种问题通过 “手动判空” 不就可以？</p></blockquote><p>事实上，<strong>在软件工程背景下，任何微小隐患都可能被 “指数级” 放大</strong>。</p><p>一个 App 页面可能有数十个，每个页面控件也可能多达十数个，而每个控件都可能分散在多个方法中，这种情况下，一味寄希望于 “手动判空”，是成本极高且存在 <strong>一致性风险</strong> —— 总会有疏忽时候，总会有 “方法 A 记得判空，而方法 B 忘记”。</p><h3 id="“函数式编程”-为何能-“彻底”-解决这类问题？"><a href="#“函数式编程”-为何能-“彻底”-解决这类问题？" class="headerlink" title="“函数式编程” 为何能 “彻底” 解决这类问题？"></a>“函数式编程” 为何能 “彻底” 解决这类问题？</h3><p>因为函数式编程基于纯函数。</p><p><strong>什么是纯函数？为何纯函数最终能解决该问题？</strong></p><p>简单来说，纯函数相比普通函数特征是：</p><p><strong>只有一个入口 &amp; 只有一个出口</strong>。</p><p>也即</p><blockquote><p>函数只从 <strong>参数列表</strong> 这唯一入口 接收外来初值，</p><p>并且只从 <strong>返回值</strong> 这唯一出口 返回结果数据。</p></blockquote><p>除此之外：</p><blockquote><p>不在函数内部执行与运算本身无关其他操作，</p><p>不在函数内部调用外部变量、不修改从外部传入的变量，</p></blockquote><p>抛开上述 TextView 的案例，我们先来举个例子看看纯函数本身：</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/5bdf1436e1d8bc1f7a8957aa509d774a.png" alt="img"></p><p>如此一来，在调用该函数时，<strong>关注点就只有 “入口和出口” 这两处</strong>，不至于蔓延到整个程序，从而 “不可预期情况” 发生概率从 99.9% 骤减为 0 —— <strong>调用者无须了解细节即可放心调用</strong>。</p><h3 id="引入-“函数式编程”-后的世界"><a href="#引入-“函数式编程”-后的世界" class="headerlink" title="引入 “函数式编程” 后的世界"></a>引入 “函数式编程” 后的世界</h3><p>函数式编程，除了单个纯函数，也可是多个纯函数链式编程，</p><p>即，<strong>上一个函数输出 作为下一个函数输入</strong>，</p><p>整个链同样只有 “开头入参” 这一入口，和 “末尾回调” 这一出口，</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/4c203f52aa7310aaea86b9782fb926f2.png" alt="img"></p><p>至此，我们得以顿悟：为何 RxJava 或 Java8 Stream 是这样写、为何会与常规 “侵入式” 思维发生 “别扭” …</p><p>是的，正由于人们习惯了 “自由散漫” 的命令式编程，从未意识到还有 “集中管理” 式，乃至遇到 RxJava 链式编程第一感觉即是，“自由散漫” 在此行不通了，</p><p>而这恰恰也是 “函数式编程” 存在意义：<strong>通过将过程原子化，来实现结果的一致性</strong> —— <strong>有怎样输入，就有且只有怎样输出</strong>，关注点只有这两处，因 “集中管理” 而从根本上杜绝不可预期结果。</p><blockquote><p>划重点 👆 👆 👆</p><p>所谓原子化即 “像原子一样不可再分、内部结构稳定、不受外力影响发生改变”。这和 “一致性” 都是大学《软件工程》课提到的概念，读书时不理解没关系，工作多年后还不理解就不对了。</p></blockquote><h2 id="所以为何会有-“声明式-UI-框架”？"><a href="#所以为何会有-“声明式-UI-框架”？" class="headerlink" title="所以为何会有 “声明式 UI 框架”？"></a>所以为何会有 “声明式 UI 框架”？</h2><blockquote><p>将 UI 系统设计为 “函数式”，反映源码设计者对 <strong>彻底解决软工安全问题</strong> 不懈追求。</p><p>正是由于这锐意进取 <strong>“死磕精神”</strong>，使软件开发得以不断优化和改进。</p></blockquote><p>通过 “混沌世界” 一节分析，我们已确知，在 “自由散漫” 环境下，<strong>实例分散可使不可预期风险被大幅扩散</strong>，</p><p>加上 <a href="https://xiaozhuanlan.com/topic/9816742350" target="_blank" rel="noopener">《从被误解到 “真香” Jetpack DataBinding》</a>“横竖屏布局控件存在差异” 这一经典案例，如采用 “自由散漫” 方式，同会埋下视图实例 Null 安全一致性问题，</p><p>而如今，函数式、响应式，意味着多种一致性问题被简化为 “数据的一致性” 这一种，开发者只需确保数据的来源是唯一且可靠的，即可通过这唯一来源的数据去驱动声明式 UI，从而得到始终一致、符合预期的结果。</p><h3 id="声明式-UI-运作流程是怎样"><a href="#声明式-UI-运作流程是怎样" class="headerlink" title="声明式 UI 运作流程是怎样"></a>声明式 UI 运作流程是怎样</h3><p>试读内容完。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://xiaozhuanlan.com/topic/2356748910" target="_blank" rel="noopener">《重学安卓：一通百通 “声明式 UI” 扫盲干货》</a></p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><blockquote><p>Copyright © 2019-present KunMinX 原创版权所有。</p></blockquote><p>如需 <strong>转载本文，或引用、借鉴</strong> 本文 “引言、思路、结论、配图” 进行二次创作发行，<strong>须注明链接出处</strong>，否则我们保留追责权利。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;blockquote&gt;
&lt;p&gt;注：本文节选自&lt;a href=&quot;https://xiaozhuanlan.com/topic/2356748910&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《重学安卓：一通百通 “声</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>View 的存在意义</title>
    <link href="https://www.kunminx.com/2020/01/29/View%20%E7%9A%84%E5%AD%98%E5%9C%A8%E6%84%8F%E4%B9%89/"/>
    <id>https://www.kunminx.com/2020/01/29/View%20%E7%9A%84%E5%AD%98%E5%9C%A8%E6%84%8F%E4%B9%89/</id>
    <published>2020-01-29T13:00:00.000Z</published>
    <updated>2023-07-25T06:54:53.983Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>注：本文节选自<a href="https://xiaozhuanlan.com/topic/2073915486" target="_blank" rel="noopener">《重学安卓：过目难忘 Android GUI 关系梳理》</a>，本文可免费阅读和全文转载，转载时须注明本文链接出处。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作多年，进阶 “细节定制”，难免高频接触 “自定义 View”、“GUI 性能优化” 等概念，</p><blockquote><p>诸如 Canvas、Paint、Path；View、Drawable；Layout、Inflater；include、merge、ViewStub；PhoneWindow、ViewRootImpl …</p></blockquote><p>关于 View 体系，开发者 <strong>普遍缺乏 “从 0 到 1 完整踩坑” 经历</strong>，且多数网文假设读者已有 <strong>前置知识</strong> 铺垫在先，因而 <strong>直奔 “What、How” 细枝末节，对 “Why” 绝口不提</strong>，</p><p>这使文章读起来 “没头没尾”，让人知难而退。</p><p>故这期我们继续 “追根溯源”，铺垫 Android GUI 系统的来龙去脉，相信阅读后，你会对 “为何要学这些技术点、每个技术的「<strong>作用边界</strong>」到底从哪到哪、技术之间的「关系和顺序」又该如何串起来” 形成清晰理解。</p><h2 id="文章目录一览"><a href="#文章目录一览" class="headerlink" title="文章目录一览"></a>文章目录一览</h2><ul><li>前言</li><li>拆解思路<ul><li>Canvas 是排版的根基</li><li>View 和 Drawable 是排版的模板</li><li>Layout 和 Inflater 不过是后来者</li><li>include，merge，ViewStub 是解药的解药</li></ul></li><li>作为承上启下的小结<ul><li>上文 “Window” 为何一直加个双引号</li><li>ViewRootImpl 是怎么帮 Canvas 与窗口对应上的</li><li>对症下药 “排版渲染” 性能优化指南</li><li>PhoneWindow 本质 及 事件分发内幕</li></ul></li><li>综上</li></ul><h2 id="Canvas-是排版的根基"><a href="#Canvas-是排版的根基" class="headerlink" title="Canvas 是排版的根基"></a>Canvas 是排版的根基</h2><p>所谓排版，即是将一个个图形化内容，以符合预期的方式组合排列，包括并列展示和层叠展示，供用户更好的浏览，</p><p>根据<a href="https://juejin.im/post/5ce651d4f265da1bb13f0a5b" target="_blank" rel="noopener">《重学安卓：Activity 快乐你不懂》</a>一文的推理，在从零开始缔造的原始操作系统中，UI 排版的工作最初是由 Window 承担，Window 不堪重负，于是责任下发到 View，通过 View/ViewGroup 在 View 树中的递归，以便更快更好完成，</p><p>那么是否意味着 View 即是排版的根基？答案是否定的，</p><p>因为 View 只是起到 “承载内容、且限制内容展示范围” 的作用，例如做过 “添加水印” 的小伙伴应该都接触过 “贴图控件”，该控件的原理是，在同一个自定义 View 中绘制多个贴图元素，那么显而易见 View 并不是排版的最小单位，被绘制的元素才是，</p><p><img src="https://images.xiaozhuanlan.com/photo/2023/5e7fc75e932c0ea94ce3a25e112d2f6e.jpeg" alt="img"></p><p>故而背后的画师 Canvas，才是排版的根基：</p><blockquote><p><strong>排版依赖于绘制</strong> —— 在排版这件事上，Canvas 可以没有 View，但 View 不能没有 Canvas。</p></blockquote><p>Paint 和 Path 都是 Canvas 的助手，<strong>与 “排版输出” 存在直接关系的 “最源头 API”</strong>，即是 Canvas 本尊。</p><h2 id="View-和-Drawable-是排版的模板"><a href="#View-和-Drawable-是排版的模板" class="headerlink" title="View 和 Drawable 是排版的模板"></a>View 和 Drawable 是排版的模板</h2><p>既然是 View 系统，那就不能只是原始、无序的 “绘制” 本身。</p><p>因而在有了 “Window” 和 Canvas 基础上，还需确立 View / ViewGroup 这样规则的 <strong>排版标准</strong>，从而我们得以基于这套 “标准” 构建 <strong>具体可复用模板</strong>。</p><blockquote><p>例如 Button、TextView、ImageView 都是 “可复用模板”，<strong>开发者日常只需与上层这些 View 打交道、无需接触底层 Canvas</strong>，无需做什么都得先手动基于 Canvas 写个数百行排版代码。</p><p>且，如对 “现成模板” 不满意，也可自行封装新模板，也即人们所说 “自定义控件”。</p></blockquote><p>与此同时，View 只是模板，如需更改可视化细节，岂不是又要接触 Canvas，</p><p>因此，同出于 <strong>灵活性和复用</strong> 考虑，衍生出 Drawable 模板设计，它的存在是用于负责更具体可视化细节：</p><p>例如通过 ShapeDrawable 来描述 <strong>View 轮廓和背景</strong>、通过 StateListDrawable 来描述 <strong>View 点击效果</strong> 等等，</p><p>使得多数情况下，我们都能直接使用 “Drawable 模板” 描述排版细节，避免良莠不齐开发者 “直接与 Canvas 打交道导致不可预知隐患”。</p><blockquote><p>划重点 👆 👆 👆</p></blockquote><table><thead><tr><th align="center">16、20、32dp 圆角</th><th align="center">16、20dp 圆角</th><th align="center">16dp 圆角</th></tr></thead><tbody><tr><td align="center"><img src="https://images.xiaozhuanlan.com/photo/2021/df4444edd0f2fb73e644149691331223.jpg" alt="img"></td><td align="center"><img src="https://images.xiaozhuanlan.com/photo/2021/a39c244b434a44a663067feb4378cf83.jpg" alt="img"></td><td align="center"><img src="https://images.xiaozhuanlan.com/photo/2021/d9aa8c6306b0ae6e2bb1c7f09ab6bb32.jpg" alt="img"></td></tr></tbody></table><blockquote><p>图片截自 “小米天气” 客户端：无处不在、各种规格圆角。</p></blockquote><h2 id="Layout-和-Inflater-不过是后来者"><a href="#Layout-和-Inflater-不过是后来者" class="headerlink" title="Layout 和 Inflater 不过是后来者"></a>Layout 和 Inflater 不过是后来者</h2><p>所以 Layout 和 LayoutInflater 是在有 View 和 Drawable 基础上，才有的后来者。</p><p>iOS 开发者常抱怨，在 iOS 上写布局，无预览，全靠想象，</p><p>为此，Google 模仿微软 WPF 设计，通过 XML 方式实现 <strong>一目了然 “声明式编程”</strong>，<strong>可实时预览 Layout、shape、selector</strong> 乃至极大方便 Android 开发者创建和修改可视化内容。</p><blockquote><p>注：Layout 对应 View 树；shape、selector 对应 Drawable。</p></blockquote><p>然而，XML 声明式编程 解决上述问题的同时，引入新问题：</p><p>1.<strong>XML 排版资源复用率极低</strong>。例如，为不同场景 Button 改圆角样式，无法像动态代码那样，直接代码中定义参数。哪怕不同样式间仅是 “圆角 dp” 存在细微差异，也得重建一个新 shape Drawable XML 描述文件。</p><p>2.XML 解析由 LayoutInflater 负责，LayoutInflater 通过 <strong>深度优先遍历</strong> 算法解析 XML <strong>构建 View 树</strong>，从而当 “布局嵌套层次加深” 等原因导致 View 个数过多时，XML 解析会愈加耗时。</p><h2 id="include，merge，ViewStub-是解药的解药"><a href="#include，merge，ViewStub-是解药的解药" class="headerlink" title="include，merge，ViewStub 是解药的解药"></a>include，merge，ViewStub 是解药的解药</h2><p>所以 XML 布局 其实只是一种 <strong>充分非必要</strong> 构建 View 树方式。</p><p>我们看到许多 “东拼西凑” 性能优化网文，不分场合兜售 include，merge，ViewStub，事实上它们仅用于 XML 布局情况 —— <strong>通过减少层级解决 inflate 耗时问题</strong>。</p><p>像 <a href="https://github.com/DrKLO/Telegram" target="_blank" rel="noopener">Telegram 源码</a> 中，这种 “全动态编码” 布局构建方式，就完全用不上从 LayoutInflater 到 ViewStub 技术点。</p><blockquote><p>划重点 👆 👆 👆</p></blockquote><h2 id="作为承上启下的小结"><a href="#作为承上启下的小结" class="headerlink" title="作为承上启下的小结"></a>作为承上启下的小结</h2><p>综上可见，无论 Button、TextView、ImageView，还是 MaterialButton、TextInputLayout 等，无论其表面如何千变万化，都不过是 <strong>为在特定场景下 “符合用户直觉” 而衍生出的排版模板</strong>，本质上都是 <strong>基于 Canvas 去绘制 “特定样式” 可视化内容</strong>。</p><p>而 Inflate 也不过是发生在当开发者选择通过 “声明式编程” 而非 “动态编码” 方式去构建 View 树。所以若非使用 LayoutInflater，开发者甚至无须知道 include，merge，ViewStub 的存在。</p><p>至此，”Window” &amp; Canvas；View &amp; Drawable；Layout &amp; Inflater；merge &amp; ViewStub，来龙去脉一目了然。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/123c9ba004c9e9e83eac64db1619c6ff.png" alt="img"></p><p>试读内容完。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://xiaozhuanlan.com/topic/2073915486" target="_blank" rel="noopener">重学安卓：过目难忘 Android GUI 关系梳理</a></p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><blockquote><p>Copyright © 2019-present KunMinX 原创版权所有。</p></blockquote><p>如需 <strong>转载本文，或引用、借鉴</strong> 本文 “引言、思路、结论、配图” 进行二次创作发行，<strong>须注明链接出处</strong>，否则我们保留追责权利。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;blockquote&gt;
&lt;p&gt;注：本文节选自&lt;a href=&quot;https://xiaozhuanlan.com/topic/2073915486&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《重学安卓：过目难忘 An</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>耳目一新 Jetpack MVVM 精讲</title>
    <link href="https://www.kunminx.com/2019/10/23/%E8%80%B3%E7%9B%AE%E4%B8%80%E6%96%B0%20Jetpack%20MVVM%20%E7%B2%BE%E8%AE%B2/"/>
    <id>https://www.kunminx.com/2019/10/23/%E8%80%B3%E7%9B%AE%E4%B8%80%E6%96%B0%20Jetpack%20MVVM%20%E7%B2%BE%E8%AE%B2/</id>
    <published>2019-10-23T06:00:00.000Z</published>
    <updated>2023-07-25T06:38:46.636Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.xiaozhuanlan.com/photo/2019/859bf0dd76e76e4f0581004499064030.png" alt=""></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近后台时而收到读者留言，说能否出一期 Jetpack MVVM 精讲，以及配套一份简练案例，好把玩把玩、感受感受、加深 MVVM 印象。</p><p>答案是肯定的。</p><h2 id="面向标准化开发已成现实"><a href="#面向标准化开发已成现实" class="headerlink" title="面向标准化开发已成现实"></a>面向标准化开发已成现实</h2><p>金九银十，相信不少读者在抓紧机会面试。</p><p>Android 市场已今非昔比。过去迫于招人压力，应试者只需了解四大组件、视图、网络请求，即可谋得一份满意工作。</p><p>现如今，Jetpack 架构组件及 “标准化开发模式” 确立，预示 Android 开发已步入成熟阶段：</p><blockquote><p>许多 “样板代码” 不再需开发者手写，而是可通过 “模版工具” 自动生成，在取缔繁杂耗时重复工作同时，<strong>避免因 “人工操作疏忽” 造成难以排查、不可预期错误</strong>。</p></blockquote><p>这十分符合企业利益，因而面试官招人时，也更加看重应试者对架构组件 —— 至少是 MVVM 理解程度。</p><p>像 “解耦” 等含糊其辞说法，不再为面试官认可，稍有 MVVM 经验面试官，都会请你举例说明，好证实你对 MVVM 确有深入理解，能自然而然写出标准化、规范化代码，能迅速适应各公司自制 “自动化模版工具”。</p><h2 id="本文目标"><a href="#本文目标" class="headerlink" title="本文目标"></a>本文目标</h2><p>本人拥有 3 年 “移动端架构” 践行和设计经验，领导或参与团队 “重构” 中大型项目多达十数个，对 Jetpack MVVM 架构在 “确立规范化、标准化开发模式，以减少不可预期错误” 所作努力，有深入理解。</p><p>因而本文目标，就是结合前几期我们分别 “深入浅出” 介绍的 Lifecycle、LiveData、ViewModel、DataBinding 来融汇贯通演绎一下：</p><p><strong>作为 “应用开发骨架” 的 “标准化状态管理框架”</strong>，究竟为快速开发过程中 “减少不可预期错误” 做了哪些努力。</p><p>不同于 “东拼西凑、人云亦云、徒添困扰” 网文，愿意将标准化开发模式 <strong>深度思考知识</strong> 和 <strong>实战反思经验</strong> 无保留分享，全网仅此一家。<strong>这样文章可以说 看一篇、少一篇</strong>，因此，就算不去 hold 住面试官，也请务必跟随本文脚步，将 Jetpack MVVM 来龙去脉过一遍。</p><h2 id="文章目录一览"><a href="#文章目录一览" class="headerlink" title="文章目录一览"></a>文章目录一览</h2><ul><li>前言</li><li>面向标准化开发已成现实</li><li>本文目标</li><li>Jetpack Lifecycle<ul><li>Lifecycle 存在前的混沌世界</li><li>Lifecycle 为什么能解决上述这些问题？</li></ul></li><li>Jetpack LiveData <ul><li>LiveData 存在前的混沌世界</li><li>LiveData 为什么能解决上述这些问题？</li><li><strong>LiveData 有个坑需要注意</strong></li></ul></li><li>Jetpack ViewModel<ul><li>ViewModel 存在前的混沌世界</li><li>ViewModel 为什么能做到这几点？</li></ul></li><li>Jetpack DataBinding <ul><li>DataBinding 存在前的混沌世界</li><li>DataBinding 就是来解决这些问题</li></ul></li><li>综上</li></ul><h2 id="Jetpack-Lifecycle"><a href="#Jetpack-Lifecycle" class="headerlink" title="Jetpack Lifecycle"></a>Jetpack Lifecycle</h2><blockquote><p><strong>Lifecycle 的存在，主要为了解决 “生命周期管理” 一致性问题</strong></p></blockquote><h3 id="Lifecycle-存在前的混沌世界"><a href="#Lifecycle-存在前的混沌世界" class="headerlink" title="Lifecycle 存在前的混沌世界"></a>Lifecycle 存在前的混沌世界</h3><p>Lifecycle 面市前，“生命周期管理” 纯靠手工维持，这容易滋生大量一致性问题。</p><p>例如跨页面共享 GpsManager 组件，在每个宿主 Activity 的 onResume 和 onPause 中都需 <strong>手动 “激活、解绑 和 叫停”</strong>。</p><p>那么 <strong>随着宿主 Activity 增多，这种手动操作埋下的 “一致性隐患” 就会指数级增长</strong>：</p><blockquote><p>一方面，凡需手工维持，开发者皆易疏忽，特别是工作交接给其他同事时，同事并不能及时注意到这些细节。</p></blockquote><blockquote><p>另一方面，分散的代码不利于修改，日后除了激活、叫停，若有其他操作补充，则每个宿主 Activity 都需额外书写一遍。</p></blockquote><p><img src="https://images.xiaozhuanlan.com/photo/2022/7391831ee0cde6dc7c13d4079c7cc6c8.png" alt=""></p><h3 id="Lifecycle-为何能解决上述这些问题？"><a href="#Lifecycle-为何能解决上述这些问题？" class="headerlink" title="Lifecycle 为何能解决上述这些问题？"></a>Lifecycle 为何能解决上述这些问题？</h3><p>Lifecycle 通过 “模板方法模式” 和 “观察者模式”，将生命周期管理的复杂操作，全在 LifecycleOwner（如 Activity、Fragment 等 “视图控制器” 基类）中封装好，默默在背后为开发者运筹帷幄，</p><p>开发者因而得以在 “视图控制器” 子类中只需一句 <code>getLifecycle().addObserver(GpsManager.getInstance)</code> ，优雅完成 “第三方组件” 在自己内部对 LifecycleOwner 生命周期 “感知”。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/d81d42452cad95b8f30fd22beafc8cce.png" alt=""></p><p>除解决一致性问题，这么做还 <strong>顺带提供其他 2 个好处</strong>：</p><blockquote><p><strong>1.规避为 “监听状态” 而注入 “视图控制器” 做法</strong></p></blockquote><p>为监听状态，传统做法是，将 Activity 作为方法参数手工注入，这埋下 “内存泄漏” 隐患 —— 因为团队新手容易因 “这有个 Activity 实例”，而在日后误将其上升为成员变量，并依赖给组件中其他成员。</p><p>现如今，我们可直接在组件内部 “点到为止” 监听 LifecycleOwner 状态，从而规避这种不恰当使用。</p><blockquote><p><strong>2.规避为 “追溯事故来源” 而注入 “视图控制器” 做法</strong></p></blockquote><p>发生事故时，传统 <strong>追溯事故来源</strong> 方式，同是向方法参数直接注入 Activity，这再次埋下 “内存泄漏” 隐患。现如今，三方组件实现 DefaultLifecycleObserver 即可在 “生命周期回调” <strong>方法作用域中</strong> 直接根据 LifecycleOwner 参数得知事故源。</p><blockquote><p>如这么说无体会，详见<a href="https://xiaozhuanlan.com/topic/3684721950" target="_blank" rel="noopener">《为你还原一个真实的 Jetpack Lifecycle》</a> 中提供的 GpsManager 案例，本文不再累述。</p></blockquote><h2 id="Jetpack-LiveData"><a href="#Jetpack-LiveData" class="headerlink" title="Jetpack LiveData"></a>Jetpack LiveData</h2><blockquote><p>LiveData 的存在，主要为了 <strong>新手老手都能不假思索遵循 “通过唯一可信源分发消息” 标准化开发理念</strong>，以便快速开发过程中 “难追溯、难排查、不可预期” 问题发生概率降低到最低。</p></blockquote><h3 id="LiveData-存在前的混沌世界"><a href="#LiveData-存在前的混沌世界" class="headerlink" title="LiveData 存在前的混沌世界"></a>LiveData 存在前的混沌世界</h3><p>LiveData 面市前，我们在 “网络请求回调、跨页面通信” 等场景分发消息，多是通过 EventBus 或 Java Interface 完成。</p><p>那这造成什么问题？首先，EventBus 等 “消息总线” 只是纯粹传话筒，它 <strong>缺乏上述 “标准化开发理念” 约束，那么人们使用该框架时，容易因 “去中心化” 滥用，造成诸如 “毫无防备收到预期外、不明来源推送”、拿到过时数据、事件源追溯复杂度放大至 n²</strong>。</p><p>且，<strong>EventBus 本身缺乏 Lifecycle 加持，存在生命周期管理一致性问题。这是 EventBus 硬伤</strong>，也是我拒绝使用 EventBus 最主要因素。</p><blockquote><p>如对上述状况无体会，可具体参考我们在 <a href="https://xiaozhuanlan.com/topic/0168753249" target="_blank" rel="noopener">《LiveData 鲜为人知 身世背景 和 独特使命》</a> 中提供的 “播放器状态全局通知” 案例。</p></blockquote><h3 id="LiveData-为何能解决上述这些问题？"><a href="#LiveData-为何能解决上述这些问题？" class="headerlink" title="LiveData 为何能解决上述这些问题？"></a>LiveData 为何能解决上述这些问题？</h3><p>首先，LiveData 是在 <strong>Google 希望确立 “标准化、规范化” 开发模式</strong> 背景下诞生，因而为达成该艰巨使命，LiveData 被十分克制设计为，<strong>仅支持状态输入和监听，且<mark>可基于 “访问权限控制” 来实现 “读写分离”</mark></strong>（protected + mutable）。</p><p><strong>这使任何一次数据推送，都可被限制为 “只能单方面从唯一可信源推送而来”（也即所谓 “单向数据流”），从而避免消息同步不一致、不可靠、在事件追溯复杂度 n² 迷宫中白费时间，</strong></p><p>也即，无论从哪个 “视图控制器” 发起消息请求，结果最终都由作为 “唯一可信源” 的单例或 SharedViewModel <strong>在其内部统一决策、一对多通知</strong>。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/0397e32176ba9e94e38f58e7a00d0da5.png" alt=""></p><p>且，这种承上启下方式，使单向依赖成为可能：单例无需通过 Java Interface 回调通知视图控制器，从而规避 “视图控制器” 被 “生命周期更长的单例” 依赖而埋下内存泄漏隐患。</p><h3 id="LiveData-有个坑需要注意"><a href="#LiveData-有个坑需要注意" class="headerlink" title="LiveData 有个坑需要注意"></a>LiveData 有个坑需要注意</h3><p>不过我个人认为，LiveData 的 Observer 设计缺乏边界感，</p><p>作为表现层承担 BehaviorSubject 职能的组件，应避免开发者直接接触 Observer 回调，并确保 “与控件属性一对一绑定”，不然开发者容易将其误用作 “一次性事件分发组件”，造成 “订阅时被自动回推脏数据”；或是开发者误使同一控件实例出现在多个 Observer 回调中，造成<a href="https://juejin.cn/post/7145317979708735496" target="_blank" rel="noopener">《MVI 存在意义》篇</a> “响应式编程漏洞” 一节所说的 “数据一致性” 问题，</p><p>经过广泛实践，发现 DataBinding 的 ObservableFiled 能做到 “与控件属性一对一绑定” 从而完美胜任表现层 BehaviorSubject 工作，因而最终决定将 LiveData 往领域层 “一次性数据分发” 的方向改造为 <a href="https://github.com/KunMinX/UnPeek-LiveData" target="_blank" rel="noopener">UnPeekLiveData</a>，使其专职 PublishSubject，</p><p>当然，由于 LiveData 存在的初衷并非是专业的 “一次性事件分发组件”，改造过的 <a href="https://github.com/KunMinX/UnPeek-LiveData" target="_blank" rel="noopener">UnPeekLiveData</a> 也只适用于 “低频次数据分发（例如每秒推送 1 次）” 场景，</p><p>因而若想满足 “高频次事件分发” 需求（例如每秒推送 5 次以上），请改用或参考专职 “领域层” 数据分发的 <a href="https://github.com/KunMinX/MVI-Dispatcher" target="_blank" rel="noopener">MVI-Dispatcher</a> 组件，该组件内部通过消息队列设计，确保不漏掉每一次推送。</p><blockquote><p>注：BehaviorSubject 和 PublishSubject 是 “响应式编程” 领域的概念，具体可参考<a href="https://juejin.cn/post/7145317979708735496" target="_blank" rel="noopener">《MVI 存在意义》篇</a> 的解析</p></blockquote><h2 id="Jetpack-ViewModel"><a href="#Jetpack-ViewModel" class="headerlink" title="Jetpack ViewModel"></a>Jetpack ViewModel</h2><blockquote><p>ViewModel 的存在，主要为了解决 “状态管理” 和 “页面通信” 问题。</p></blockquote><h3 id="ViewModel-存在前的混沌世界"><a href="#ViewModel-存在前的混沌世界" class="headerlink" title="ViewModel 存在前的混沌世界"></a>ViewModel 存在前的混沌世界</h3><p>ViewModel 本职工作是 <strong>状态托管</strong> 和 <strong>状态管理 “分治”</strong>，也即当视图控制器重建时，</p><blockquote><p>对于轻量状态，可通过 “视图控制器” 基类 saveInstanceState 机制，以序列化方式完成存储和恢复。</p></blockquote><blockquote><p>对于重量级状态，例如通过网络请求得到的 List，可通过生命周期长于视图控制器的 ViewModel 持有，从而得以直接从 ViewModel 恢复，而不是以效率较低的序列化方式。</p></blockquote><p>在 Jetpack ViewModel 面市之前，MVP 的 Presenter 和 MVVM - Clean 的 ViewModel，由于生命周期短于视图控制器，它们顶多为 DataBinding 提供状态托管，而无法实现状态分治。</p><p>到了 Jetpack 这版，ViewModel 以精妙设计，达成状态管理，及可共享作用域。</p><h3 id="ViewModel-为何能做到这几点？"><a href="#ViewModel-为何能做到这几点？" class="headerlink" title="ViewModel 为何能做到这几点？"></a>ViewModel 为何能做到这几点？</h3><p>其实这版主要基于 <strong>工厂模式</strong>，使 ViewModel <strong>被 LifecycleOwner 所持有、通过 ViewModelProvider 来引用</strong>，</p><p>所以 <strong>它既类似于单例：</strong><br>—— 当被作为 LifecycleOwner 的 Activity 持有时，能脱离 Activity 旗下 Fragment 生命周期，从而实现作用域共享，</p><p><strong>实际上又不是单例：</strong><br>—— 生命周期跟随作为 LifecycleOwner 的视图控制器，当 Owner（Activity 或 Fragment）被销毁时，它也被 clear。</p><blockquote><p>此外，出于对视图控制器 “重建” 考虑，Google 在视图控制器基类中通过 retain 机制对 ViewModel 进行保留。</p></blockquote><blockquote><p>因此，对于 “作用域共享” 和 “视图重建” 情况，状态因完好被保留，而得以被视图控制器在恢复时直接使用。</p></blockquote><p>再者，由于存在 “共享作用域” 考虑，ViewModel 本身也承担了跨页面通信职责。此场景下 LiveData “数据倒灌” 问题，上文已介绍，不再累述。</p><blockquote><p>Note：截至 2020.2.1，ViewModel 在 Fragment 中 retain 设计已发生剧变，具体缘由可参考我们在 <a href="https://xiaozhuanlan.com/topic/6257931840" target="_blank" rel="noopener">《页面开发 左右逢源  Jetpack ViewModel》</a> 文末及评论区最新补充。</p></blockquote><h2 id="Jetpack-DataBinding"><a href="#Jetpack-DataBinding" class="headerlink" title="Jetpack DataBinding"></a>Jetpack DataBinding</h2><blockquote><p>DataBinding 的存在，主要为了解决 “View 实例 Null 安全” 一致性问题。</p></blockquote><h3 id="DataBinding-存在前的混沌世界"><a href="#DataBinding-存在前的混沌世界" class="headerlink" title="DataBinding 存在前的混沌世界"></a>DataBinding 存在前的混沌世界</h3><p>DataBinding 面市前，我们若要改变视图状态，唯有先调用该 View 实例，如 textView.setText( )，</p><p>这造成什么问题？</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ac4caf1cad24cc89b9918127fc8baa7~tplv-k3u1fbpfcp-watermark.image" alt=""></p><blockquote><p>当页面存在横、竖布局，且两种布局控件存在差异，例如横屏存在 textView 控件，而竖屏没有，那么我们便不得不在 “视图控制器” 中为 textView 做判空处理，这就造成一致性问题 —— <strong>容易疏忽而忘记判空</strong>，毕竟页面多达数十个、每个页面调用控件的地方也无数。</p></blockquote><p>那怎么办？</p><h3 id="DataBinding-就是来解决这些问题"><a href="#DataBinding-就是来解决这些问题" class="headerlink" title="DataBinding 就是来解决这些问题"></a>DataBinding 就是来解决这些问题</h3><p>通过让 “控件” 与 “可观察数据” 发生绑定，那么当该数据被 set 新内容时，被绑定该数据的控件即可被通知和刷新。</p><blockquote><p>Note 2020.4.18：这一切都是 “编译时自动生成中间代码” 在背后完成的逻辑衔接，也即控件如存在于布局中（例如竖屏布局中）且绑定了可观察数据，就会被调用和通知，如不存在（例如横屏布局中），就没被调用，无论哪一种情况，都不至于发生 Null 安全一致性问题。</p></blockquote><p>换言之，使用 DataBinding 后，唯一的改变是，你无需 “手工调用 View 实例” 来 set 新状态，你只需 set 可观察数据本身。</p><p>因而，<strong>DataBinding 并非许多人不假思索认为的，将 UI 逻辑搬到 XML 中写、从而难以调试 —— 事实并非如此：</strong></p><p><strong>DataBinding 只负责绑定数据、<mark>负责 “作为 UI 逻辑末端状态” 的改变</mark></strong>（也即它是一个不可再分原子操作，本就不需调试），原本在视图控制器中 UI 逻辑怎么写，现还是怎么写，只不过不再需要 textView.setText(xxx)，而是直接 xxx.set( )。</p><p>所以在 DataBinding 帮助下，好处总共多少个？</p><blockquote><p>1.规避 View 实例 Null 安全一致性问题 —— 无需手工判空。</p></blockquote><blockquote><p>2.规避 View 实例 Null 安全一致性问题，乃至无需手动调用 View，从而完全不用写 findViewById。</p></blockquote><blockquote><p>3.就算要调用 View，也不用 findViewById，而是直接通过 mBinding 调用。</p></blockquote><blockquote><p>4.先前 UI 逻辑基本不用改动，改的只是 “改变末端状态” 方式。</p></blockquote><p>……</p><p>此外，<strong>DataBinding 有个大杀器：能为控件提供自定义属性的 BindingAdapter</strong>，它不仅可解决圆角 Drawable 复用问题，还可实现 imageView 直接绑定 url 等需求，总之，没有它办不到，只有你想不到，DataBinding 好处等着你挖掘。</p><p>关于 DataBinding 注意事项、屡试不爽排坑技巧，以及独家解析 <mark>“<strong>DataBinding 严格模式</strong>”</mark>，可具体参考 <a href="https://xiaozhuanlan.com/topic/9816742350" target="_blank" rel="noopener">《从被误解到 “真香”  Jetpack DataBinding》</a>，这里不做累述。</p><h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p>Lifecycle 的存在，主要为了解决 <strong>“生命周期管理” 一致性问题</strong>。</p><p>LiveData 的存在，主要为了实现 <strong>“消息分发可靠一致”</strong>。</p><p>ViewModel 的存在，主要为了解决 <strong>“状态管理” 一致性问题</strong>。</p><p>DataBinding 的存在，主要为了解决 <strong>“View 实例 Null 安全” 一致性问题</strong>。</p><p>它们的存在，大都为在 “软件工程” 背景下解决一致性问题、将易出错操作封装于后台，<strong>方便使用者 “快速、稳定、不产生预期外错误” 编码</strong>。</p><blockquote><p>全文完</p></blockquote><h2 id="本文配套项目"><a href="#本文配套项目" class="headerlink" title="本文配套项目"></a>本文配套项目</h2><p><img src="https://images.xiaozhuanlan.com/photo/2023/b10d6c52e0cdb4197725059399fad12f.jpg" alt=""></p><p><a href="https://github.com/KunMinX/Jetpack-MVVM-Best-Practice" target="_blank" rel="noopener">GitHub : Jetpack-MVVM-Best-Practice</a></p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><p>本文以 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">CC 署名-非商业性使用-禁止演绎 4.0 国际协议</a> 发行。</p><p>Copyright © 2019-present KunMinX</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7418d1c58ad14ee0b942e992798d56b2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>文中提到的 “xxx 架构组件的存在，是为了在 多人协作软件工程背景下 <strong>解决 xxx 一致性问题</strong>”，以及 “LiveData 在页面通信、事件回调场景下发生 <strong>数据倒灌</strong>” 等多处 <strong>对特定现象及其本质匹配和概括，均属于本人独立原创成果</strong>，本人对此享有所有权和最终解释权。</p><p>当您借鉴或引用本文 引言、思路、结论进行二次创作，或全文转载时，须注明链接出处，否则我们保留追责权利。</p><p>未经与作者本人当面沟通许可，不得将文章内容用于洗稿、广告包装等商业用途。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2019/859bf0dd76e76e4f0581004499064030.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
